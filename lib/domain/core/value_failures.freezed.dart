// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named

part of 'value_failures.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

mixin _$ValueFailure<T> {
  T get failedValue;

  ValueFailure<T> copyWith({T failedValue});

  @optionalTypeArgs
  Result when<Result extends Object>({
    @required
        Result exceedingLength(@required T failedValue, @required int max),
    @required Result empty(@required T failedValue),
    @required Result multiline(@required T failedValue),
    @required Result invalidNumber(@required T failedValue),
    @required Result numberToLow(@required T failedValue),
    @required Result numberToBig(@required T failedValue),
    @required Result invalidEmail(@required T failedValue),
    @required Result emailMissingDot(@required T failedValue),
    @required Result emailHasSpace(@required T failedValue),
    @required Result invalidPassword(@required T failedValue),
    @required Result invalidPhoneNumber(@required T failedValue),
    @required Result phoneNumberNotStartsWith3(@required T failedValue),
    @required Result notValidOperatorMX(@required T failedValue),
    @required Result invalidName(@required T failedValue),
    @required Result nameTooShort(@required T failedValue),
    @required Result nameTooLong(@required T failedValue),
    @required Result phoneNumberToShort(@required T failedValue),
    @required Result goalMinPassed(@required T failedValue),
    @required Result underMin(@required T failedValue),
    @required Result emailHasSpaceBeginning(@required T failedValue),
    @required Result missingDotAfterExt(@required T failedValue),
  });

  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result exceedingLength(@required T failedValue, @required int max),
    Result empty(@required T failedValue),
    Result multiline(@required T failedValue),
    Result invalidNumber(@required T failedValue),
    Result numberToLow(@required T failedValue),
    Result numberToBig(@required T failedValue),
    Result invalidEmail(@required T failedValue),
    Result emailMissingDot(@required T failedValue),
    Result emailHasSpace(@required T failedValue),
    Result invalidPassword(@required T failedValue),
    Result invalidPhoneNumber(@required T failedValue),
    Result phoneNumberNotStartsWith3(@required T failedValue),
    Result notValidOperatorMX(@required T failedValue),
    Result invalidName(@required T failedValue),
    Result nameTooShort(@required T failedValue),
    Result nameTooLong(@required T failedValue),
    Result phoneNumberToShort(@required T failedValue),
    Result goalMinPassed(@required T failedValue),
    Result underMin(@required T failedValue),
    Result emailHasSpaceBeginning(@required T failedValue),
    Result missingDotAfterExt(@required T failedValue),
    @required Result orElse(),
  });

  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result exceedingLength(ExceedingLength<T> value),
    @required Result empty(Empty<T> value),
    @required Result multiline(Multiline<T> value),
    @required Result invalidNumber(InvalidNumber<T> value),
    @required Result numberToLow(NumberToLow<T> value),
    @required Result numberToBig(NumberToBig<T> value),
    @required Result invalidEmail(InvalidEmail<T> value),
    @required Result emailMissingDot(EmailMissingDot<T> value),
    @required Result emailHasSpace(EmailHasSpace<T> value),
    @required Result invalidPassword(InvalidPassword<T> value),
    @required Result invalidPhoneNumber(InvalidPhoneNumber<T> value),
    @required
        Result phoneNumberNotStartsWith3(PhoneNumberNotStartsWith3<T> value),
    @required Result notValidOperatorMX(NotValidOperatorMX<T> value),
    @required Result invalidName(InvalidName<T> value),
    @required Result nameTooShort(NameTooShort<T> value),
    @required Result nameTooLong(NameTooLong<T> value),
    @required Result phoneNumberToShort(PhoneNumberTooShort<T> value),
    @required Result goalMinPassed(GoalMinPassed<T> value),
    @required Result underMin(UnderMin<T> value),
    @required Result emailHasSpaceBeginning(EmailHasSpaceBeginning<T> value),
    @required Result missingDotAfterExt(MissingDotAfterExt<T> value),
  });

  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result exceedingLength(ExceedingLength<T> value),
    Result empty(Empty<T> value),
    Result multiline(Multiline<T> value),
    Result invalidNumber(InvalidNumber<T> value),
    Result numberToLow(NumberToLow<T> value),
    Result numberToBig(NumberToBig<T> value),
    Result invalidEmail(InvalidEmail<T> value),
    Result emailMissingDot(EmailMissingDot<T> value),
    Result emailHasSpace(EmailHasSpace<T> value),
    Result invalidPassword(InvalidPassword<T> value),
    Result invalidPhoneNumber(InvalidPhoneNumber<T> value),
    Result phoneNumberNotStartsWith3(PhoneNumberNotStartsWith3<T> value),
    Result notValidOperatorMX(NotValidOperatorMX<T> value),
    Result invalidName(InvalidName<T> value),
    Result nameTooShort(NameTooShort<T> value),
    Result nameTooLong(NameTooLong<T> value),
    Result phoneNumberToShort(PhoneNumberTooShort<T> value),
    Result goalMinPassed(GoalMinPassed<T> value),
    Result underMin(UnderMin<T> value),
    Result emailHasSpaceBeginning(EmailHasSpaceBeginning<T> value),
    Result missingDotAfterExt(MissingDotAfterExt<T> value),
    @required Result orElse(),
  });
}

class _$ValueFailureTearOff {
  const _$ValueFailureTearOff();

  ExceedingLength<T> exceedingLength<T>(
      {@required T failedValue, @required int max}) {
    return ExceedingLength<T>(
      failedValue: failedValue,
      max: max,
    );
  }

  Empty<T> empty<T>({@required T failedValue}) {
    return Empty<T>(
      failedValue: failedValue,
    );
  }

  Multiline<T> multiline<T>({@required T failedValue}) {
    return Multiline<T>(
      failedValue: failedValue,
    );
  }

  InvalidNumber<T> invalidNumber<T>({@required T failedValue}) {
    return InvalidNumber<T>(
      failedValue: failedValue,
    );
  }

  NumberToLow<T> numberToLow<T>({@required T failedValue}) {
    return NumberToLow<T>(
      failedValue: failedValue,
    );
  }

  NumberToBig<T> numberToBig<T>({@required T failedValue}) {
    return NumberToBig<T>(
      failedValue: failedValue,
    );
  }

  InvalidEmail<T> invalidEmail<T>({@required T failedValue}) {
    return InvalidEmail<T>(
      failedValue: failedValue,
    );
  }

  EmailMissingDot<T> emailMissingDot<T>({@required T failedValue}) {
    return EmailMissingDot<T>(
      failedValue: failedValue,
    );
  }

  EmailHasSpace<T> emailHasSpace<T>({@required T failedValue}) {
    return EmailHasSpace<T>(
      failedValue: failedValue,
    );
  }

  InvalidPassword<T> invalidPassword<T>({@required T failedValue}) {
    return InvalidPassword<T>(
      failedValue: failedValue,
    );
  }

  InvalidPhoneNumber<T> invalidPhoneNumber<T>({@required T failedValue}) {
    return InvalidPhoneNumber<T>(
      failedValue: failedValue,
    );
  }

  PhoneNumberNotStartsWith3<T> phoneNumberNotStartsWith3<T>(
      {@required T failedValue}) {
    return PhoneNumberNotStartsWith3<T>(
      failedValue: failedValue,
    );
  }

  NotValidOperatorMX<T> notValidOperatorMX<T>({@required T failedValue}) {
    return NotValidOperatorMX<T>(
      failedValue: failedValue,
    );
  }

  InvalidName<T> invalidName<T>({@required T failedValue}) {
    return InvalidName<T>(
      failedValue: failedValue,
    );
  }

  NameTooShort<T> nameTooShort<T>({@required T failedValue}) {
    return NameTooShort<T>(
      failedValue: failedValue,
    );
  }

  NameTooLong<T> nameTooLong<T>({@required T failedValue}) {
    return NameTooLong<T>(
      failedValue: failedValue,
    );
  }

  PhoneNumberTooShort<T> phoneNumberToShort<T>({@required T failedValue}) {
    return PhoneNumberTooShort<T>(
      failedValue: failedValue,
    );
  }

  GoalMinPassed<T> goalMinPassed<T>({@required T failedValue}) {
    return GoalMinPassed<T>(
      failedValue: failedValue,
    );
  }

  UnderMin<T> underMin<T>({@required T failedValue}) {
    return UnderMin<T>(
      failedValue: failedValue,
    );
  }

  EmailHasSpaceBeginning<T> emailHasSpaceBeginning<T>(
      {@required T failedValue}) {
    return EmailHasSpaceBeginning<T>(
      failedValue: failedValue,
    );
  }

  MissingDotAfterExt<T> missingDotAfterExt<T>({@required T failedValue}) {
    return MissingDotAfterExt<T>(
      failedValue: failedValue,
    );
  }
}

const $ValueFailure = _$ValueFailureTearOff();

class _$ExceedingLength<T>
    with DiagnosticableTreeMixin
    implements ExceedingLength<T> {
  const _$ExceedingLength({@required this.failedValue, @required this.max})
      : assert(failedValue != null),
        assert(max != null);

  @override
  final T failedValue;
  @override
  final int max;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ValueFailure<$T>.exceedingLength(failedValue: $failedValue, max: $max)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ValueFailure<$T>.exceedingLength'))
      ..add(DiagnosticsProperty('failedValue', failedValue))
      ..add(DiagnosticsProperty('max', max));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ExceedingLength<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)) &&
            (identical(other.max, max) ||
                const DeepCollectionEquality().equals(other.max, max)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(failedValue) ^
      const DeepCollectionEquality().hash(max);

  @override
  _$ExceedingLength<T> copyWith({
    Object failedValue = freezed,
    Object max = freezed,
  }) {
    return _$ExceedingLength<T>(
      failedValue: failedValue == freezed ? this.failedValue : failedValue as T,
      max: max == freezed ? this.max : max as int,
    );
  }

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required
        Result exceedingLength(@required T failedValue, @required int max),
    @required Result empty(@required T failedValue),
    @required Result multiline(@required T failedValue),
    @required Result invalidNumber(@required T failedValue),
    @required Result numberToLow(@required T failedValue),
    @required Result numberToBig(@required T failedValue),
    @required Result invalidEmail(@required T failedValue),
    @required Result emailMissingDot(@required T failedValue),
    @required Result emailHasSpace(@required T failedValue),
    @required Result invalidPassword(@required T failedValue),
    @required Result invalidPhoneNumber(@required T failedValue),
    @required Result phoneNumberNotStartsWith3(@required T failedValue),
    @required Result notValidOperatorMX(@required T failedValue),
    @required Result invalidName(@required T failedValue),
    @required Result nameTooShort(@required T failedValue),
    @required Result nameTooLong(@required T failedValue),
    @required Result phoneNumberToShort(@required T failedValue),
    @required Result goalMinPassed(@required T failedValue),
    @required Result underMin(@required T failedValue),
    @required Result emailHasSpaceBeginning(@required T failedValue),
    @required Result missingDotAfterExt(@required T failedValue),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(invalidNumber != null);
    assert(numberToLow != null);
    assert(numberToBig != null);
    assert(invalidEmail != null);
    assert(emailMissingDot != null);
    assert(emailHasSpace != null);
    assert(invalidPassword != null);
    assert(invalidPhoneNumber != null);
    assert(phoneNumberNotStartsWith3 != null);
    assert(notValidOperatorMX != null);
    assert(invalidName != null);
    assert(nameTooShort != null);
    assert(nameTooLong != null);
    assert(phoneNumberToShort != null);
    assert(goalMinPassed != null);
    assert(underMin != null);
    assert(emailHasSpaceBeginning != null);
    assert(missingDotAfterExt != null);
    return exceedingLength(failedValue, max);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result exceedingLength(@required T failedValue, @required int max),
    Result empty(@required T failedValue),
    Result multiline(@required T failedValue),
    Result invalidNumber(@required T failedValue),
    Result numberToLow(@required T failedValue),
    Result numberToBig(@required T failedValue),
    Result invalidEmail(@required T failedValue),
    Result emailMissingDot(@required T failedValue),
    Result emailHasSpace(@required T failedValue),
    Result invalidPassword(@required T failedValue),
    Result invalidPhoneNumber(@required T failedValue),
    Result phoneNumberNotStartsWith3(@required T failedValue),
    Result notValidOperatorMX(@required T failedValue),
    Result invalidName(@required T failedValue),
    Result nameTooShort(@required T failedValue),
    Result nameTooLong(@required T failedValue),
    Result phoneNumberToShort(@required T failedValue),
    Result goalMinPassed(@required T failedValue),
    Result underMin(@required T failedValue),
    Result emailHasSpaceBeginning(@required T failedValue),
    Result missingDotAfterExt(@required T failedValue),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (exceedingLength != null) {
      return exceedingLength(failedValue, max);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result exceedingLength(ExceedingLength<T> value),
    @required Result empty(Empty<T> value),
    @required Result multiline(Multiline<T> value),
    @required Result invalidNumber(InvalidNumber<T> value),
    @required Result numberToLow(NumberToLow<T> value),
    @required Result numberToBig(NumberToBig<T> value),
    @required Result invalidEmail(InvalidEmail<T> value),
    @required Result emailMissingDot(EmailMissingDot<T> value),
    @required Result emailHasSpace(EmailHasSpace<T> value),
    @required Result invalidPassword(InvalidPassword<T> value),
    @required Result invalidPhoneNumber(InvalidPhoneNumber<T> value),
    @required
        Result phoneNumberNotStartsWith3(PhoneNumberNotStartsWith3<T> value),
    @required Result notValidOperatorMX(NotValidOperatorMX<T> value),
    @required Result invalidName(InvalidName<T> value),
    @required Result nameTooShort(NameTooShort<T> value),
    @required Result nameTooLong(NameTooLong<T> value),
    @required Result phoneNumberToShort(PhoneNumberTooShort<T> value),
    @required Result goalMinPassed(GoalMinPassed<T> value),
    @required Result underMin(UnderMin<T> value),
    @required Result emailHasSpaceBeginning(EmailHasSpaceBeginning<T> value),
    @required Result missingDotAfterExt(MissingDotAfterExt<T> value),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(invalidNumber != null);
    assert(numberToLow != null);
    assert(numberToBig != null);
    assert(invalidEmail != null);
    assert(emailMissingDot != null);
    assert(emailHasSpace != null);
    assert(invalidPassword != null);
    assert(invalidPhoneNumber != null);
    assert(phoneNumberNotStartsWith3 != null);
    assert(notValidOperatorMX != null);
    assert(invalidName != null);
    assert(nameTooShort != null);
    assert(nameTooLong != null);
    assert(phoneNumberToShort != null);
    assert(goalMinPassed != null);
    assert(underMin != null);
    assert(emailHasSpaceBeginning != null);
    assert(missingDotAfterExt != null);
    return exceedingLength(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result exceedingLength(ExceedingLength<T> value),
    Result empty(Empty<T> value),
    Result multiline(Multiline<T> value),
    Result invalidNumber(InvalidNumber<T> value),
    Result numberToLow(NumberToLow<T> value),
    Result numberToBig(NumberToBig<T> value),
    Result invalidEmail(InvalidEmail<T> value),
    Result emailMissingDot(EmailMissingDot<T> value),
    Result emailHasSpace(EmailHasSpace<T> value),
    Result invalidPassword(InvalidPassword<T> value),
    Result invalidPhoneNumber(InvalidPhoneNumber<T> value),
    Result phoneNumberNotStartsWith3(PhoneNumberNotStartsWith3<T> value),
    Result notValidOperatorMX(NotValidOperatorMX<T> value),
    Result invalidName(InvalidName<T> value),
    Result nameTooShort(NameTooShort<T> value),
    Result nameTooLong(NameTooLong<T> value),
    Result phoneNumberToShort(PhoneNumberTooShort<T> value),
    Result goalMinPassed(GoalMinPassed<T> value),
    Result underMin(UnderMin<T> value),
    Result emailHasSpaceBeginning(EmailHasSpaceBeginning<T> value),
    Result missingDotAfterExt(MissingDotAfterExt<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (exceedingLength != null) {
      return exceedingLength(this);
    }
    return orElse();
  }
}

abstract class ExceedingLength<T> implements ValueFailure<T> {
  const factory ExceedingLength({@required T failedValue, @required int max}) =
      _$ExceedingLength<T>;

  @override
  T get failedValue;
  int get max;

  @override
  ExceedingLength<T> copyWith({T failedValue, int max});
}

class _$Empty<T> with DiagnosticableTreeMixin implements Empty<T> {
  const _$Empty({@required this.failedValue}) : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ValueFailure<$T>.empty(failedValue: $failedValue)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ValueFailure<$T>.empty'))
      ..add(DiagnosticsProperty('failedValue', failedValue));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Empty<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  _$Empty<T> copyWith({
    Object failedValue = freezed,
  }) {
    return _$Empty<T>(
      failedValue: failedValue == freezed ? this.failedValue : failedValue as T,
    );
  }

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required
        Result exceedingLength(@required T failedValue, @required int max),
    @required Result empty(@required T failedValue),
    @required Result multiline(@required T failedValue),
    @required Result invalidNumber(@required T failedValue),
    @required Result numberToLow(@required T failedValue),
    @required Result numberToBig(@required T failedValue),
    @required Result invalidEmail(@required T failedValue),
    @required Result emailMissingDot(@required T failedValue),
    @required Result emailHasSpace(@required T failedValue),
    @required Result invalidPassword(@required T failedValue),
    @required Result invalidPhoneNumber(@required T failedValue),
    @required Result phoneNumberNotStartsWith3(@required T failedValue),
    @required Result notValidOperatorMX(@required T failedValue),
    @required Result invalidName(@required T failedValue),
    @required Result nameTooShort(@required T failedValue),
    @required Result nameTooLong(@required T failedValue),
    @required Result phoneNumberToShort(@required T failedValue),
    @required Result goalMinPassed(@required T failedValue),
    @required Result underMin(@required T failedValue),
    @required Result emailHasSpaceBeginning(@required T failedValue),
    @required Result missingDotAfterExt(@required T failedValue),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(invalidNumber != null);
    assert(numberToLow != null);
    assert(numberToBig != null);
    assert(invalidEmail != null);
    assert(emailMissingDot != null);
    assert(emailHasSpace != null);
    assert(invalidPassword != null);
    assert(invalidPhoneNumber != null);
    assert(phoneNumberNotStartsWith3 != null);
    assert(notValidOperatorMX != null);
    assert(invalidName != null);
    assert(nameTooShort != null);
    assert(nameTooLong != null);
    assert(phoneNumberToShort != null);
    assert(goalMinPassed != null);
    assert(underMin != null);
    assert(emailHasSpaceBeginning != null);
    assert(missingDotAfterExt != null);
    return empty(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result exceedingLength(@required T failedValue, @required int max),
    Result empty(@required T failedValue),
    Result multiline(@required T failedValue),
    Result invalidNumber(@required T failedValue),
    Result numberToLow(@required T failedValue),
    Result numberToBig(@required T failedValue),
    Result invalidEmail(@required T failedValue),
    Result emailMissingDot(@required T failedValue),
    Result emailHasSpace(@required T failedValue),
    Result invalidPassword(@required T failedValue),
    Result invalidPhoneNumber(@required T failedValue),
    Result phoneNumberNotStartsWith3(@required T failedValue),
    Result notValidOperatorMX(@required T failedValue),
    Result invalidName(@required T failedValue),
    Result nameTooShort(@required T failedValue),
    Result nameTooLong(@required T failedValue),
    Result phoneNumberToShort(@required T failedValue),
    Result goalMinPassed(@required T failedValue),
    Result underMin(@required T failedValue),
    Result emailHasSpaceBeginning(@required T failedValue),
    Result missingDotAfterExt(@required T failedValue),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (empty != null) {
      return empty(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result exceedingLength(ExceedingLength<T> value),
    @required Result empty(Empty<T> value),
    @required Result multiline(Multiline<T> value),
    @required Result invalidNumber(InvalidNumber<T> value),
    @required Result numberToLow(NumberToLow<T> value),
    @required Result numberToBig(NumberToBig<T> value),
    @required Result invalidEmail(InvalidEmail<T> value),
    @required Result emailMissingDot(EmailMissingDot<T> value),
    @required Result emailHasSpace(EmailHasSpace<T> value),
    @required Result invalidPassword(InvalidPassword<T> value),
    @required Result invalidPhoneNumber(InvalidPhoneNumber<T> value),
    @required
        Result phoneNumberNotStartsWith3(PhoneNumberNotStartsWith3<T> value),
    @required Result notValidOperatorMX(NotValidOperatorMX<T> value),
    @required Result invalidName(InvalidName<T> value),
    @required Result nameTooShort(NameTooShort<T> value),
    @required Result nameTooLong(NameTooLong<T> value),
    @required Result phoneNumberToShort(PhoneNumberTooShort<T> value),
    @required Result goalMinPassed(GoalMinPassed<T> value),
    @required Result underMin(UnderMin<T> value),
    @required Result emailHasSpaceBeginning(EmailHasSpaceBeginning<T> value),
    @required Result missingDotAfterExt(MissingDotAfterExt<T> value),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(invalidNumber != null);
    assert(numberToLow != null);
    assert(numberToBig != null);
    assert(invalidEmail != null);
    assert(emailMissingDot != null);
    assert(emailHasSpace != null);
    assert(invalidPassword != null);
    assert(invalidPhoneNumber != null);
    assert(phoneNumberNotStartsWith3 != null);
    assert(notValidOperatorMX != null);
    assert(invalidName != null);
    assert(nameTooShort != null);
    assert(nameTooLong != null);
    assert(phoneNumberToShort != null);
    assert(goalMinPassed != null);
    assert(underMin != null);
    assert(emailHasSpaceBeginning != null);
    assert(missingDotAfterExt != null);
    return empty(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result exceedingLength(ExceedingLength<T> value),
    Result empty(Empty<T> value),
    Result multiline(Multiline<T> value),
    Result invalidNumber(InvalidNumber<T> value),
    Result numberToLow(NumberToLow<T> value),
    Result numberToBig(NumberToBig<T> value),
    Result invalidEmail(InvalidEmail<T> value),
    Result emailMissingDot(EmailMissingDot<T> value),
    Result emailHasSpace(EmailHasSpace<T> value),
    Result invalidPassword(InvalidPassword<T> value),
    Result invalidPhoneNumber(InvalidPhoneNumber<T> value),
    Result phoneNumberNotStartsWith3(PhoneNumberNotStartsWith3<T> value),
    Result notValidOperatorMX(NotValidOperatorMX<T> value),
    Result invalidName(InvalidName<T> value),
    Result nameTooShort(NameTooShort<T> value),
    Result nameTooLong(NameTooLong<T> value),
    Result phoneNumberToShort(PhoneNumberTooShort<T> value),
    Result goalMinPassed(GoalMinPassed<T> value),
    Result underMin(UnderMin<T> value),
    Result emailHasSpaceBeginning(EmailHasSpaceBeginning<T> value),
    Result missingDotAfterExt(MissingDotAfterExt<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (empty != null) {
      return empty(this);
    }
    return orElse();
  }
}

abstract class Empty<T> implements ValueFailure<T> {
  const factory Empty({@required T failedValue}) = _$Empty<T>;

  @override
  T get failedValue;

  @override
  Empty<T> copyWith({T failedValue});
}

class _$Multiline<T> with DiagnosticableTreeMixin implements Multiline<T> {
  const _$Multiline({@required this.failedValue}) : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ValueFailure<$T>.multiline(failedValue: $failedValue)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ValueFailure<$T>.multiline'))
      ..add(DiagnosticsProperty('failedValue', failedValue));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Multiline<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  _$Multiline<T> copyWith({
    Object failedValue = freezed,
  }) {
    return _$Multiline<T>(
      failedValue: failedValue == freezed ? this.failedValue : failedValue as T,
    );
  }

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required
        Result exceedingLength(@required T failedValue, @required int max),
    @required Result empty(@required T failedValue),
    @required Result multiline(@required T failedValue),
    @required Result invalidNumber(@required T failedValue),
    @required Result numberToLow(@required T failedValue),
    @required Result numberToBig(@required T failedValue),
    @required Result invalidEmail(@required T failedValue),
    @required Result emailMissingDot(@required T failedValue),
    @required Result emailHasSpace(@required T failedValue),
    @required Result invalidPassword(@required T failedValue),
    @required Result invalidPhoneNumber(@required T failedValue),
    @required Result phoneNumberNotStartsWith3(@required T failedValue),
    @required Result notValidOperatorMX(@required T failedValue),
    @required Result invalidName(@required T failedValue),
    @required Result nameTooShort(@required T failedValue),
    @required Result nameTooLong(@required T failedValue),
    @required Result phoneNumberToShort(@required T failedValue),
    @required Result goalMinPassed(@required T failedValue),
    @required Result underMin(@required T failedValue),
    @required Result emailHasSpaceBeginning(@required T failedValue),
    @required Result missingDotAfterExt(@required T failedValue),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(invalidNumber != null);
    assert(numberToLow != null);
    assert(numberToBig != null);
    assert(invalidEmail != null);
    assert(emailMissingDot != null);
    assert(emailHasSpace != null);
    assert(invalidPassword != null);
    assert(invalidPhoneNumber != null);
    assert(phoneNumberNotStartsWith3 != null);
    assert(notValidOperatorMX != null);
    assert(invalidName != null);
    assert(nameTooShort != null);
    assert(nameTooLong != null);
    assert(phoneNumberToShort != null);
    assert(goalMinPassed != null);
    assert(underMin != null);
    assert(emailHasSpaceBeginning != null);
    assert(missingDotAfterExt != null);
    return multiline(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result exceedingLength(@required T failedValue, @required int max),
    Result empty(@required T failedValue),
    Result multiline(@required T failedValue),
    Result invalidNumber(@required T failedValue),
    Result numberToLow(@required T failedValue),
    Result numberToBig(@required T failedValue),
    Result invalidEmail(@required T failedValue),
    Result emailMissingDot(@required T failedValue),
    Result emailHasSpace(@required T failedValue),
    Result invalidPassword(@required T failedValue),
    Result invalidPhoneNumber(@required T failedValue),
    Result phoneNumberNotStartsWith3(@required T failedValue),
    Result notValidOperatorMX(@required T failedValue),
    Result invalidName(@required T failedValue),
    Result nameTooShort(@required T failedValue),
    Result nameTooLong(@required T failedValue),
    Result phoneNumberToShort(@required T failedValue),
    Result goalMinPassed(@required T failedValue),
    Result underMin(@required T failedValue),
    Result emailHasSpaceBeginning(@required T failedValue),
    Result missingDotAfterExt(@required T failedValue),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (multiline != null) {
      return multiline(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result exceedingLength(ExceedingLength<T> value),
    @required Result empty(Empty<T> value),
    @required Result multiline(Multiline<T> value),
    @required Result invalidNumber(InvalidNumber<T> value),
    @required Result numberToLow(NumberToLow<T> value),
    @required Result numberToBig(NumberToBig<T> value),
    @required Result invalidEmail(InvalidEmail<T> value),
    @required Result emailMissingDot(EmailMissingDot<T> value),
    @required Result emailHasSpace(EmailHasSpace<T> value),
    @required Result invalidPassword(InvalidPassword<T> value),
    @required Result invalidPhoneNumber(InvalidPhoneNumber<T> value),
    @required
        Result phoneNumberNotStartsWith3(PhoneNumberNotStartsWith3<T> value),
    @required Result notValidOperatorMX(NotValidOperatorMX<T> value),
    @required Result invalidName(InvalidName<T> value),
    @required Result nameTooShort(NameTooShort<T> value),
    @required Result nameTooLong(NameTooLong<T> value),
    @required Result phoneNumberToShort(PhoneNumberTooShort<T> value),
    @required Result goalMinPassed(GoalMinPassed<T> value),
    @required Result underMin(UnderMin<T> value),
    @required Result emailHasSpaceBeginning(EmailHasSpaceBeginning<T> value),
    @required Result missingDotAfterExt(MissingDotAfterExt<T> value),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(invalidNumber != null);
    assert(numberToLow != null);
    assert(numberToBig != null);
    assert(invalidEmail != null);
    assert(emailMissingDot != null);
    assert(emailHasSpace != null);
    assert(invalidPassword != null);
    assert(invalidPhoneNumber != null);
    assert(phoneNumberNotStartsWith3 != null);
    assert(notValidOperatorMX != null);
    assert(invalidName != null);
    assert(nameTooShort != null);
    assert(nameTooLong != null);
    assert(phoneNumberToShort != null);
    assert(goalMinPassed != null);
    assert(underMin != null);
    assert(emailHasSpaceBeginning != null);
    assert(missingDotAfterExt != null);
    return multiline(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result exceedingLength(ExceedingLength<T> value),
    Result empty(Empty<T> value),
    Result multiline(Multiline<T> value),
    Result invalidNumber(InvalidNumber<T> value),
    Result numberToLow(NumberToLow<T> value),
    Result numberToBig(NumberToBig<T> value),
    Result invalidEmail(InvalidEmail<T> value),
    Result emailMissingDot(EmailMissingDot<T> value),
    Result emailHasSpace(EmailHasSpace<T> value),
    Result invalidPassword(InvalidPassword<T> value),
    Result invalidPhoneNumber(InvalidPhoneNumber<T> value),
    Result phoneNumberNotStartsWith3(PhoneNumberNotStartsWith3<T> value),
    Result notValidOperatorMX(NotValidOperatorMX<T> value),
    Result invalidName(InvalidName<T> value),
    Result nameTooShort(NameTooShort<T> value),
    Result nameTooLong(NameTooLong<T> value),
    Result phoneNumberToShort(PhoneNumberTooShort<T> value),
    Result goalMinPassed(GoalMinPassed<T> value),
    Result underMin(UnderMin<T> value),
    Result emailHasSpaceBeginning(EmailHasSpaceBeginning<T> value),
    Result missingDotAfterExt(MissingDotAfterExt<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (multiline != null) {
      return multiline(this);
    }
    return orElse();
  }
}

abstract class Multiline<T> implements ValueFailure<T> {
  const factory Multiline({@required T failedValue}) = _$Multiline<T>;

  @override
  T get failedValue;

  @override
  Multiline<T> copyWith({T failedValue});
}

class _$InvalidNumber<T>
    with DiagnosticableTreeMixin
    implements InvalidNumber<T> {
  const _$InvalidNumber({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ValueFailure<$T>.invalidNumber(failedValue: $failedValue)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ValueFailure<$T>.invalidNumber'))
      ..add(DiagnosticsProperty('failedValue', failedValue));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidNumber<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  _$InvalidNumber<T> copyWith({
    Object failedValue = freezed,
  }) {
    return _$InvalidNumber<T>(
      failedValue: failedValue == freezed ? this.failedValue : failedValue as T,
    );
  }

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required
        Result exceedingLength(@required T failedValue, @required int max),
    @required Result empty(@required T failedValue),
    @required Result multiline(@required T failedValue),
    @required Result invalidNumber(@required T failedValue),
    @required Result numberToLow(@required T failedValue),
    @required Result numberToBig(@required T failedValue),
    @required Result invalidEmail(@required T failedValue),
    @required Result emailMissingDot(@required T failedValue),
    @required Result emailHasSpace(@required T failedValue),
    @required Result invalidPassword(@required T failedValue),
    @required Result invalidPhoneNumber(@required T failedValue),
    @required Result phoneNumberNotStartsWith3(@required T failedValue),
    @required Result notValidOperatorMX(@required T failedValue),
    @required Result invalidName(@required T failedValue),
    @required Result nameTooShort(@required T failedValue),
    @required Result nameTooLong(@required T failedValue),
    @required Result phoneNumberToShort(@required T failedValue),
    @required Result goalMinPassed(@required T failedValue),
    @required Result underMin(@required T failedValue),
    @required Result emailHasSpaceBeginning(@required T failedValue),
    @required Result missingDotAfterExt(@required T failedValue),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(invalidNumber != null);
    assert(numberToLow != null);
    assert(numberToBig != null);
    assert(invalidEmail != null);
    assert(emailMissingDot != null);
    assert(emailHasSpace != null);
    assert(invalidPassword != null);
    assert(invalidPhoneNumber != null);
    assert(phoneNumberNotStartsWith3 != null);
    assert(notValidOperatorMX != null);
    assert(invalidName != null);
    assert(nameTooShort != null);
    assert(nameTooLong != null);
    assert(phoneNumberToShort != null);
    assert(goalMinPassed != null);
    assert(underMin != null);
    assert(emailHasSpaceBeginning != null);
    assert(missingDotAfterExt != null);
    return invalidNumber(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result exceedingLength(@required T failedValue, @required int max),
    Result empty(@required T failedValue),
    Result multiline(@required T failedValue),
    Result invalidNumber(@required T failedValue),
    Result numberToLow(@required T failedValue),
    Result numberToBig(@required T failedValue),
    Result invalidEmail(@required T failedValue),
    Result emailMissingDot(@required T failedValue),
    Result emailHasSpace(@required T failedValue),
    Result invalidPassword(@required T failedValue),
    Result invalidPhoneNumber(@required T failedValue),
    Result phoneNumberNotStartsWith3(@required T failedValue),
    Result notValidOperatorMX(@required T failedValue),
    Result invalidName(@required T failedValue),
    Result nameTooShort(@required T failedValue),
    Result nameTooLong(@required T failedValue),
    Result phoneNumberToShort(@required T failedValue),
    Result goalMinPassed(@required T failedValue),
    Result underMin(@required T failedValue),
    Result emailHasSpaceBeginning(@required T failedValue),
    Result missingDotAfterExt(@required T failedValue),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidNumber != null) {
      return invalidNumber(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result exceedingLength(ExceedingLength<T> value),
    @required Result empty(Empty<T> value),
    @required Result multiline(Multiline<T> value),
    @required Result invalidNumber(InvalidNumber<T> value),
    @required Result numberToLow(NumberToLow<T> value),
    @required Result numberToBig(NumberToBig<T> value),
    @required Result invalidEmail(InvalidEmail<T> value),
    @required Result emailMissingDot(EmailMissingDot<T> value),
    @required Result emailHasSpace(EmailHasSpace<T> value),
    @required Result invalidPassword(InvalidPassword<T> value),
    @required Result invalidPhoneNumber(InvalidPhoneNumber<T> value),
    @required
        Result phoneNumberNotStartsWith3(PhoneNumberNotStartsWith3<T> value),
    @required Result notValidOperatorMX(NotValidOperatorMX<T> value),
    @required Result invalidName(InvalidName<T> value),
    @required Result nameTooShort(NameTooShort<T> value),
    @required Result nameTooLong(NameTooLong<T> value),
    @required Result phoneNumberToShort(PhoneNumberTooShort<T> value),
    @required Result goalMinPassed(GoalMinPassed<T> value),
    @required Result underMin(UnderMin<T> value),
    @required Result emailHasSpaceBeginning(EmailHasSpaceBeginning<T> value),
    @required Result missingDotAfterExt(MissingDotAfterExt<T> value),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(invalidNumber != null);
    assert(numberToLow != null);
    assert(numberToBig != null);
    assert(invalidEmail != null);
    assert(emailMissingDot != null);
    assert(emailHasSpace != null);
    assert(invalidPassword != null);
    assert(invalidPhoneNumber != null);
    assert(phoneNumberNotStartsWith3 != null);
    assert(notValidOperatorMX != null);
    assert(invalidName != null);
    assert(nameTooShort != null);
    assert(nameTooLong != null);
    assert(phoneNumberToShort != null);
    assert(goalMinPassed != null);
    assert(underMin != null);
    assert(emailHasSpaceBeginning != null);
    assert(missingDotAfterExt != null);
    return invalidNumber(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result exceedingLength(ExceedingLength<T> value),
    Result empty(Empty<T> value),
    Result multiline(Multiline<T> value),
    Result invalidNumber(InvalidNumber<T> value),
    Result numberToLow(NumberToLow<T> value),
    Result numberToBig(NumberToBig<T> value),
    Result invalidEmail(InvalidEmail<T> value),
    Result emailMissingDot(EmailMissingDot<T> value),
    Result emailHasSpace(EmailHasSpace<T> value),
    Result invalidPassword(InvalidPassword<T> value),
    Result invalidPhoneNumber(InvalidPhoneNumber<T> value),
    Result phoneNumberNotStartsWith3(PhoneNumberNotStartsWith3<T> value),
    Result notValidOperatorMX(NotValidOperatorMX<T> value),
    Result invalidName(InvalidName<T> value),
    Result nameTooShort(NameTooShort<T> value),
    Result nameTooLong(NameTooLong<T> value),
    Result phoneNumberToShort(PhoneNumberTooShort<T> value),
    Result goalMinPassed(GoalMinPassed<T> value),
    Result underMin(UnderMin<T> value),
    Result emailHasSpaceBeginning(EmailHasSpaceBeginning<T> value),
    Result missingDotAfterExt(MissingDotAfterExt<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidNumber != null) {
      return invalidNumber(this);
    }
    return orElse();
  }
}

abstract class InvalidNumber<T> implements ValueFailure<T> {
  const factory InvalidNumber({@required T failedValue}) = _$InvalidNumber<T>;

  @override
  T get failedValue;

  @override
  InvalidNumber<T> copyWith({T failedValue});
}

class _$NumberToLow<T> with DiagnosticableTreeMixin implements NumberToLow<T> {
  const _$NumberToLow({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ValueFailure<$T>.numberToLow(failedValue: $failedValue)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ValueFailure<$T>.numberToLow'))
      ..add(DiagnosticsProperty('failedValue', failedValue));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is NumberToLow<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  _$NumberToLow<T> copyWith({
    Object failedValue = freezed,
  }) {
    return _$NumberToLow<T>(
      failedValue: failedValue == freezed ? this.failedValue : failedValue as T,
    );
  }

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required
        Result exceedingLength(@required T failedValue, @required int max),
    @required Result empty(@required T failedValue),
    @required Result multiline(@required T failedValue),
    @required Result invalidNumber(@required T failedValue),
    @required Result numberToLow(@required T failedValue),
    @required Result numberToBig(@required T failedValue),
    @required Result invalidEmail(@required T failedValue),
    @required Result emailMissingDot(@required T failedValue),
    @required Result emailHasSpace(@required T failedValue),
    @required Result invalidPassword(@required T failedValue),
    @required Result invalidPhoneNumber(@required T failedValue),
    @required Result phoneNumberNotStartsWith3(@required T failedValue),
    @required Result notValidOperatorMX(@required T failedValue),
    @required Result invalidName(@required T failedValue),
    @required Result nameTooShort(@required T failedValue),
    @required Result nameTooLong(@required T failedValue),
    @required Result phoneNumberToShort(@required T failedValue),
    @required Result goalMinPassed(@required T failedValue),
    @required Result underMin(@required T failedValue),
    @required Result emailHasSpaceBeginning(@required T failedValue),
    @required Result missingDotAfterExt(@required T failedValue),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(invalidNumber != null);
    assert(numberToLow != null);
    assert(numberToBig != null);
    assert(invalidEmail != null);
    assert(emailMissingDot != null);
    assert(emailHasSpace != null);
    assert(invalidPassword != null);
    assert(invalidPhoneNumber != null);
    assert(phoneNumberNotStartsWith3 != null);
    assert(notValidOperatorMX != null);
    assert(invalidName != null);
    assert(nameTooShort != null);
    assert(nameTooLong != null);
    assert(phoneNumberToShort != null);
    assert(goalMinPassed != null);
    assert(underMin != null);
    assert(emailHasSpaceBeginning != null);
    assert(missingDotAfterExt != null);
    return numberToLow(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result exceedingLength(@required T failedValue, @required int max),
    Result empty(@required T failedValue),
    Result multiline(@required T failedValue),
    Result invalidNumber(@required T failedValue),
    Result numberToLow(@required T failedValue),
    Result numberToBig(@required T failedValue),
    Result invalidEmail(@required T failedValue),
    Result emailMissingDot(@required T failedValue),
    Result emailHasSpace(@required T failedValue),
    Result invalidPassword(@required T failedValue),
    Result invalidPhoneNumber(@required T failedValue),
    Result phoneNumberNotStartsWith3(@required T failedValue),
    Result notValidOperatorMX(@required T failedValue),
    Result invalidName(@required T failedValue),
    Result nameTooShort(@required T failedValue),
    Result nameTooLong(@required T failedValue),
    Result phoneNumberToShort(@required T failedValue),
    Result goalMinPassed(@required T failedValue),
    Result underMin(@required T failedValue),
    Result emailHasSpaceBeginning(@required T failedValue),
    Result missingDotAfterExt(@required T failedValue),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (numberToLow != null) {
      return numberToLow(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result exceedingLength(ExceedingLength<T> value),
    @required Result empty(Empty<T> value),
    @required Result multiline(Multiline<T> value),
    @required Result invalidNumber(InvalidNumber<T> value),
    @required Result numberToLow(NumberToLow<T> value),
    @required Result numberToBig(NumberToBig<T> value),
    @required Result invalidEmail(InvalidEmail<T> value),
    @required Result emailMissingDot(EmailMissingDot<T> value),
    @required Result emailHasSpace(EmailHasSpace<T> value),
    @required Result invalidPassword(InvalidPassword<T> value),
    @required Result invalidPhoneNumber(InvalidPhoneNumber<T> value),
    @required
        Result phoneNumberNotStartsWith3(PhoneNumberNotStartsWith3<T> value),
    @required Result notValidOperatorMX(NotValidOperatorMX<T> value),
    @required Result invalidName(InvalidName<T> value),
    @required Result nameTooShort(NameTooShort<T> value),
    @required Result nameTooLong(NameTooLong<T> value),
    @required Result phoneNumberToShort(PhoneNumberTooShort<T> value),
    @required Result goalMinPassed(GoalMinPassed<T> value),
    @required Result underMin(UnderMin<T> value),
    @required Result emailHasSpaceBeginning(EmailHasSpaceBeginning<T> value),
    @required Result missingDotAfterExt(MissingDotAfterExt<T> value),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(invalidNumber != null);
    assert(numberToLow != null);
    assert(numberToBig != null);
    assert(invalidEmail != null);
    assert(emailMissingDot != null);
    assert(emailHasSpace != null);
    assert(invalidPassword != null);
    assert(invalidPhoneNumber != null);
    assert(phoneNumberNotStartsWith3 != null);
    assert(notValidOperatorMX != null);
    assert(invalidName != null);
    assert(nameTooShort != null);
    assert(nameTooLong != null);
    assert(phoneNumberToShort != null);
    assert(goalMinPassed != null);
    assert(underMin != null);
    assert(emailHasSpaceBeginning != null);
    assert(missingDotAfterExt != null);
    return numberToLow(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result exceedingLength(ExceedingLength<T> value),
    Result empty(Empty<T> value),
    Result multiline(Multiline<T> value),
    Result invalidNumber(InvalidNumber<T> value),
    Result numberToLow(NumberToLow<T> value),
    Result numberToBig(NumberToBig<T> value),
    Result invalidEmail(InvalidEmail<T> value),
    Result emailMissingDot(EmailMissingDot<T> value),
    Result emailHasSpace(EmailHasSpace<T> value),
    Result invalidPassword(InvalidPassword<T> value),
    Result invalidPhoneNumber(InvalidPhoneNumber<T> value),
    Result phoneNumberNotStartsWith3(PhoneNumberNotStartsWith3<T> value),
    Result notValidOperatorMX(NotValidOperatorMX<T> value),
    Result invalidName(InvalidName<T> value),
    Result nameTooShort(NameTooShort<T> value),
    Result nameTooLong(NameTooLong<T> value),
    Result phoneNumberToShort(PhoneNumberTooShort<T> value),
    Result goalMinPassed(GoalMinPassed<T> value),
    Result underMin(UnderMin<T> value),
    Result emailHasSpaceBeginning(EmailHasSpaceBeginning<T> value),
    Result missingDotAfterExt(MissingDotAfterExt<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (numberToLow != null) {
      return numberToLow(this);
    }
    return orElse();
  }
}

abstract class NumberToLow<T> implements ValueFailure<T> {
  const factory NumberToLow({@required T failedValue}) = _$NumberToLow<T>;

  @override
  T get failedValue;

  @override
  NumberToLow<T> copyWith({T failedValue});
}

class _$NumberToBig<T> with DiagnosticableTreeMixin implements NumberToBig<T> {
  const _$NumberToBig({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ValueFailure<$T>.numberToBig(failedValue: $failedValue)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ValueFailure<$T>.numberToBig'))
      ..add(DiagnosticsProperty('failedValue', failedValue));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is NumberToBig<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  _$NumberToBig<T> copyWith({
    Object failedValue = freezed,
  }) {
    return _$NumberToBig<T>(
      failedValue: failedValue == freezed ? this.failedValue : failedValue as T,
    );
  }

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required
        Result exceedingLength(@required T failedValue, @required int max),
    @required Result empty(@required T failedValue),
    @required Result multiline(@required T failedValue),
    @required Result invalidNumber(@required T failedValue),
    @required Result numberToLow(@required T failedValue),
    @required Result numberToBig(@required T failedValue),
    @required Result invalidEmail(@required T failedValue),
    @required Result emailMissingDot(@required T failedValue),
    @required Result emailHasSpace(@required T failedValue),
    @required Result invalidPassword(@required T failedValue),
    @required Result invalidPhoneNumber(@required T failedValue),
    @required Result phoneNumberNotStartsWith3(@required T failedValue),
    @required Result notValidOperatorMX(@required T failedValue),
    @required Result invalidName(@required T failedValue),
    @required Result nameTooShort(@required T failedValue),
    @required Result nameTooLong(@required T failedValue),
    @required Result phoneNumberToShort(@required T failedValue),
    @required Result goalMinPassed(@required T failedValue),
    @required Result underMin(@required T failedValue),
    @required Result emailHasSpaceBeginning(@required T failedValue),
    @required Result missingDotAfterExt(@required T failedValue),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(invalidNumber != null);
    assert(numberToLow != null);
    assert(numberToBig != null);
    assert(invalidEmail != null);
    assert(emailMissingDot != null);
    assert(emailHasSpace != null);
    assert(invalidPassword != null);
    assert(invalidPhoneNumber != null);
    assert(phoneNumberNotStartsWith3 != null);
    assert(notValidOperatorMX != null);
    assert(invalidName != null);
    assert(nameTooShort != null);
    assert(nameTooLong != null);
    assert(phoneNumberToShort != null);
    assert(goalMinPassed != null);
    assert(underMin != null);
    assert(emailHasSpaceBeginning != null);
    assert(missingDotAfterExt != null);
    return numberToBig(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result exceedingLength(@required T failedValue, @required int max),
    Result empty(@required T failedValue),
    Result multiline(@required T failedValue),
    Result invalidNumber(@required T failedValue),
    Result numberToLow(@required T failedValue),
    Result numberToBig(@required T failedValue),
    Result invalidEmail(@required T failedValue),
    Result emailMissingDot(@required T failedValue),
    Result emailHasSpace(@required T failedValue),
    Result invalidPassword(@required T failedValue),
    Result invalidPhoneNumber(@required T failedValue),
    Result phoneNumberNotStartsWith3(@required T failedValue),
    Result notValidOperatorMX(@required T failedValue),
    Result invalidName(@required T failedValue),
    Result nameTooShort(@required T failedValue),
    Result nameTooLong(@required T failedValue),
    Result phoneNumberToShort(@required T failedValue),
    Result goalMinPassed(@required T failedValue),
    Result underMin(@required T failedValue),
    Result emailHasSpaceBeginning(@required T failedValue),
    Result missingDotAfterExt(@required T failedValue),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (numberToBig != null) {
      return numberToBig(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result exceedingLength(ExceedingLength<T> value),
    @required Result empty(Empty<T> value),
    @required Result multiline(Multiline<T> value),
    @required Result invalidNumber(InvalidNumber<T> value),
    @required Result numberToLow(NumberToLow<T> value),
    @required Result numberToBig(NumberToBig<T> value),
    @required Result invalidEmail(InvalidEmail<T> value),
    @required Result emailMissingDot(EmailMissingDot<T> value),
    @required Result emailHasSpace(EmailHasSpace<T> value),
    @required Result invalidPassword(InvalidPassword<T> value),
    @required Result invalidPhoneNumber(InvalidPhoneNumber<T> value),
    @required
        Result phoneNumberNotStartsWith3(PhoneNumberNotStartsWith3<T> value),
    @required Result notValidOperatorMX(NotValidOperatorMX<T> value),
    @required Result invalidName(InvalidName<T> value),
    @required Result nameTooShort(NameTooShort<T> value),
    @required Result nameTooLong(NameTooLong<T> value),
    @required Result phoneNumberToShort(PhoneNumberTooShort<T> value),
    @required Result goalMinPassed(GoalMinPassed<T> value),
    @required Result underMin(UnderMin<T> value),
    @required Result emailHasSpaceBeginning(EmailHasSpaceBeginning<T> value),
    @required Result missingDotAfterExt(MissingDotAfterExt<T> value),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(invalidNumber != null);
    assert(numberToLow != null);
    assert(numberToBig != null);
    assert(invalidEmail != null);
    assert(emailMissingDot != null);
    assert(emailHasSpace != null);
    assert(invalidPassword != null);
    assert(invalidPhoneNumber != null);
    assert(phoneNumberNotStartsWith3 != null);
    assert(notValidOperatorMX != null);
    assert(invalidName != null);
    assert(nameTooShort != null);
    assert(nameTooLong != null);
    assert(phoneNumberToShort != null);
    assert(goalMinPassed != null);
    assert(underMin != null);
    assert(emailHasSpaceBeginning != null);
    assert(missingDotAfterExt != null);
    return numberToBig(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result exceedingLength(ExceedingLength<T> value),
    Result empty(Empty<T> value),
    Result multiline(Multiline<T> value),
    Result invalidNumber(InvalidNumber<T> value),
    Result numberToLow(NumberToLow<T> value),
    Result numberToBig(NumberToBig<T> value),
    Result invalidEmail(InvalidEmail<T> value),
    Result emailMissingDot(EmailMissingDot<T> value),
    Result emailHasSpace(EmailHasSpace<T> value),
    Result invalidPassword(InvalidPassword<T> value),
    Result invalidPhoneNumber(InvalidPhoneNumber<T> value),
    Result phoneNumberNotStartsWith3(PhoneNumberNotStartsWith3<T> value),
    Result notValidOperatorMX(NotValidOperatorMX<T> value),
    Result invalidName(InvalidName<T> value),
    Result nameTooShort(NameTooShort<T> value),
    Result nameTooLong(NameTooLong<T> value),
    Result phoneNumberToShort(PhoneNumberTooShort<T> value),
    Result goalMinPassed(GoalMinPassed<T> value),
    Result underMin(UnderMin<T> value),
    Result emailHasSpaceBeginning(EmailHasSpaceBeginning<T> value),
    Result missingDotAfterExt(MissingDotAfterExt<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (numberToBig != null) {
      return numberToBig(this);
    }
    return orElse();
  }
}

abstract class NumberToBig<T> implements ValueFailure<T> {
  const factory NumberToBig({@required T failedValue}) = _$NumberToBig<T>;

  @override
  T get failedValue;

  @override
  NumberToBig<T> copyWith({T failedValue});
}

class _$InvalidEmail<T>
    with DiagnosticableTreeMixin
    implements InvalidEmail<T> {
  const _$InvalidEmail({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ValueFailure<$T>.invalidEmail(failedValue: $failedValue)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ValueFailure<$T>.invalidEmail'))
      ..add(DiagnosticsProperty('failedValue', failedValue));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidEmail<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  _$InvalidEmail<T> copyWith({
    Object failedValue = freezed,
  }) {
    return _$InvalidEmail<T>(
      failedValue: failedValue == freezed ? this.failedValue : failedValue as T,
    );
  }

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required
        Result exceedingLength(@required T failedValue, @required int max),
    @required Result empty(@required T failedValue),
    @required Result multiline(@required T failedValue),
    @required Result invalidNumber(@required T failedValue),
    @required Result numberToLow(@required T failedValue),
    @required Result numberToBig(@required T failedValue),
    @required Result invalidEmail(@required T failedValue),
    @required Result emailMissingDot(@required T failedValue),
    @required Result emailHasSpace(@required T failedValue),
    @required Result invalidPassword(@required T failedValue),
    @required Result invalidPhoneNumber(@required T failedValue),
    @required Result phoneNumberNotStartsWith3(@required T failedValue),
    @required Result notValidOperatorMX(@required T failedValue),
    @required Result invalidName(@required T failedValue),
    @required Result nameTooShort(@required T failedValue),
    @required Result nameTooLong(@required T failedValue),
    @required Result phoneNumberToShort(@required T failedValue),
    @required Result goalMinPassed(@required T failedValue),
    @required Result underMin(@required T failedValue),
    @required Result emailHasSpaceBeginning(@required T failedValue),
    @required Result missingDotAfterExt(@required T failedValue),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(invalidNumber != null);
    assert(numberToLow != null);
    assert(numberToBig != null);
    assert(invalidEmail != null);
    assert(emailMissingDot != null);
    assert(emailHasSpace != null);
    assert(invalidPassword != null);
    assert(invalidPhoneNumber != null);
    assert(phoneNumberNotStartsWith3 != null);
    assert(notValidOperatorMX != null);
    assert(invalidName != null);
    assert(nameTooShort != null);
    assert(nameTooLong != null);
    assert(phoneNumberToShort != null);
    assert(goalMinPassed != null);
    assert(underMin != null);
    assert(emailHasSpaceBeginning != null);
    assert(missingDotAfterExt != null);
    return invalidEmail(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result exceedingLength(@required T failedValue, @required int max),
    Result empty(@required T failedValue),
    Result multiline(@required T failedValue),
    Result invalidNumber(@required T failedValue),
    Result numberToLow(@required T failedValue),
    Result numberToBig(@required T failedValue),
    Result invalidEmail(@required T failedValue),
    Result emailMissingDot(@required T failedValue),
    Result emailHasSpace(@required T failedValue),
    Result invalidPassword(@required T failedValue),
    Result invalidPhoneNumber(@required T failedValue),
    Result phoneNumberNotStartsWith3(@required T failedValue),
    Result notValidOperatorMX(@required T failedValue),
    Result invalidName(@required T failedValue),
    Result nameTooShort(@required T failedValue),
    Result nameTooLong(@required T failedValue),
    Result phoneNumberToShort(@required T failedValue),
    Result goalMinPassed(@required T failedValue),
    Result underMin(@required T failedValue),
    Result emailHasSpaceBeginning(@required T failedValue),
    Result missingDotAfterExt(@required T failedValue),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidEmail != null) {
      return invalidEmail(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result exceedingLength(ExceedingLength<T> value),
    @required Result empty(Empty<T> value),
    @required Result multiline(Multiline<T> value),
    @required Result invalidNumber(InvalidNumber<T> value),
    @required Result numberToLow(NumberToLow<T> value),
    @required Result numberToBig(NumberToBig<T> value),
    @required Result invalidEmail(InvalidEmail<T> value),
    @required Result emailMissingDot(EmailMissingDot<T> value),
    @required Result emailHasSpace(EmailHasSpace<T> value),
    @required Result invalidPassword(InvalidPassword<T> value),
    @required Result invalidPhoneNumber(InvalidPhoneNumber<T> value),
    @required
        Result phoneNumberNotStartsWith3(PhoneNumberNotStartsWith3<T> value),
    @required Result notValidOperatorMX(NotValidOperatorMX<T> value),
    @required Result invalidName(InvalidName<T> value),
    @required Result nameTooShort(NameTooShort<T> value),
    @required Result nameTooLong(NameTooLong<T> value),
    @required Result phoneNumberToShort(PhoneNumberTooShort<T> value),
    @required Result goalMinPassed(GoalMinPassed<T> value),
    @required Result underMin(UnderMin<T> value),
    @required Result emailHasSpaceBeginning(EmailHasSpaceBeginning<T> value),
    @required Result missingDotAfterExt(MissingDotAfterExt<T> value),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(invalidNumber != null);
    assert(numberToLow != null);
    assert(numberToBig != null);
    assert(invalidEmail != null);
    assert(emailMissingDot != null);
    assert(emailHasSpace != null);
    assert(invalidPassword != null);
    assert(invalidPhoneNumber != null);
    assert(phoneNumberNotStartsWith3 != null);
    assert(notValidOperatorMX != null);
    assert(invalidName != null);
    assert(nameTooShort != null);
    assert(nameTooLong != null);
    assert(phoneNumberToShort != null);
    assert(goalMinPassed != null);
    assert(underMin != null);
    assert(emailHasSpaceBeginning != null);
    assert(missingDotAfterExt != null);
    return invalidEmail(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result exceedingLength(ExceedingLength<T> value),
    Result empty(Empty<T> value),
    Result multiline(Multiline<T> value),
    Result invalidNumber(InvalidNumber<T> value),
    Result numberToLow(NumberToLow<T> value),
    Result numberToBig(NumberToBig<T> value),
    Result invalidEmail(InvalidEmail<T> value),
    Result emailMissingDot(EmailMissingDot<T> value),
    Result emailHasSpace(EmailHasSpace<T> value),
    Result invalidPassword(InvalidPassword<T> value),
    Result invalidPhoneNumber(InvalidPhoneNumber<T> value),
    Result phoneNumberNotStartsWith3(PhoneNumberNotStartsWith3<T> value),
    Result notValidOperatorMX(NotValidOperatorMX<T> value),
    Result invalidName(InvalidName<T> value),
    Result nameTooShort(NameTooShort<T> value),
    Result nameTooLong(NameTooLong<T> value),
    Result phoneNumberToShort(PhoneNumberTooShort<T> value),
    Result goalMinPassed(GoalMinPassed<T> value),
    Result underMin(UnderMin<T> value),
    Result emailHasSpaceBeginning(EmailHasSpaceBeginning<T> value),
    Result missingDotAfterExt(MissingDotAfterExt<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidEmail != null) {
      return invalidEmail(this);
    }
    return orElse();
  }
}

abstract class InvalidEmail<T> implements ValueFailure<T> {
  const factory InvalidEmail({@required T failedValue}) = _$InvalidEmail<T>;

  @override
  T get failedValue;

  @override
  InvalidEmail<T> copyWith({T failedValue});
}

class _$EmailMissingDot<T>
    with DiagnosticableTreeMixin
    implements EmailMissingDot<T> {
  const _$EmailMissingDot({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ValueFailure<$T>.emailMissingDot(failedValue: $failedValue)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ValueFailure<$T>.emailMissingDot'))
      ..add(DiagnosticsProperty('failedValue', failedValue));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is EmailMissingDot<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  _$EmailMissingDot<T> copyWith({
    Object failedValue = freezed,
  }) {
    return _$EmailMissingDot<T>(
      failedValue: failedValue == freezed ? this.failedValue : failedValue as T,
    );
  }

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required
        Result exceedingLength(@required T failedValue, @required int max),
    @required Result empty(@required T failedValue),
    @required Result multiline(@required T failedValue),
    @required Result invalidNumber(@required T failedValue),
    @required Result numberToLow(@required T failedValue),
    @required Result numberToBig(@required T failedValue),
    @required Result invalidEmail(@required T failedValue),
    @required Result emailMissingDot(@required T failedValue),
    @required Result emailHasSpace(@required T failedValue),
    @required Result invalidPassword(@required T failedValue),
    @required Result invalidPhoneNumber(@required T failedValue),
    @required Result phoneNumberNotStartsWith3(@required T failedValue),
    @required Result notValidOperatorMX(@required T failedValue),
    @required Result invalidName(@required T failedValue),
    @required Result nameTooShort(@required T failedValue),
    @required Result nameTooLong(@required T failedValue),
    @required Result phoneNumberToShort(@required T failedValue),
    @required Result goalMinPassed(@required T failedValue),
    @required Result underMin(@required T failedValue),
    @required Result emailHasSpaceBeginning(@required T failedValue),
    @required Result missingDotAfterExt(@required T failedValue),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(invalidNumber != null);
    assert(numberToLow != null);
    assert(numberToBig != null);
    assert(invalidEmail != null);
    assert(emailMissingDot != null);
    assert(emailHasSpace != null);
    assert(invalidPassword != null);
    assert(invalidPhoneNumber != null);
    assert(phoneNumberNotStartsWith3 != null);
    assert(notValidOperatorMX != null);
    assert(invalidName != null);
    assert(nameTooShort != null);
    assert(nameTooLong != null);
    assert(phoneNumberToShort != null);
    assert(goalMinPassed != null);
    assert(underMin != null);
    assert(emailHasSpaceBeginning != null);
    assert(missingDotAfterExt != null);
    return emailMissingDot(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result exceedingLength(@required T failedValue, @required int max),
    Result empty(@required T failedValue),
    Result multiline(@required T failedValue),
    Result invalidNumber(@required T failedValue),
    Result numberToLow(@required T failedValue),
    Result numberToBig(@required T failedValue),
    Result invalidEmail(@required T failedValue),
    Result emailMissingDot(@required T failedValue),
    Result emailHasSpace(@required T failedValue),
    Result invalidPassword(@required T failedValue),
    Result invalidPhoneNumber(@required T failedValue),
    Result phoneNumberNotStartsWith3(@required T failedValue),
    Result notValidOperatorMX(@required T failedValue),
    Result invalidName(@required T failedValue),
    Result nameTooShort(@required T failedValue),
    Result nameTooLong(@required T failedValue),
    Result phoneNumberToShort(@required T failedValue),
    Result goalMinPassed(@required T failedValue),
    Result underMin(@required T failedValue),
    Result emailHasSpaceBeginning(@required T failedValue),
    Result missingDotAfterExt(@required T failedValue),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (emailMissingDot != null) {
      return emailMissingDot(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result exceedingLength(ExceedingLength<T> value),
    @required Result empty(Empty<T> value),
    @required Result multiline(Multiline<T> value),
    @required Result invalidNumber(InvalidNumber<T> value),
    @required Result numberToLow(NumberToLow<T> value),
    @required Result numberToBig(NumberToBig<T> value),
    @required Result invalidEmail(InvalidEmail<T> value),
    @required Result emailMissingDot(EmailMissingDot<T> value),
    @required Result emailHasSpace(EmailHasSpace<T> value),
    @required Result invalidPassword(InvalidPassword<T> value),
    @required Result invalidPhoneNumber(InvalidPhoneNumber<T> value),
    @required
        Result phoneNumberNotStartsWith3(PhoneNumberNotStartsWith3<T> value),
    @required Result notValidOperatorMX(NotValidOperatorMX<T> value),
    @required Result invalidName(InvalidName<T> value),
    @required Result nameTooShort(NameTooShort<T> value),
    @required Result nameTooLong(NameTooLong<T> value),
    @required Result phoneNumberToShort(PhoneNumberTooShort<T> value),
    @required Result goalMinPassed(GoalMinPassed<T> value),
    @required Result underMin(UnderMin<T> value),
    @required Result emailHasSpaceBeginning(EmailHasSpaceBeginning<T> value),
    @required Result missingDotAfterExt(MissingDotAfterExt<T> value),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(invalidNumber != null);
    assert(numberToLow != null);
    assert(numberToBig != null);
    assert(invalidEmail != null);
    assert(emailMissingDot != null);
    assert(emailHasSpace != null);
    assert(invalidPassword != null);
    assert(invalidPhoneNumber != null);
    assert(phoneNumberNotStartsWith3 != null);
    assert(notValidOperatorMX != null);
    assert(invalidName != null);
    assert(nameTooShort != null);
    assert(nameTooLong != null);
    assert(phoneNumberToShort != null);
    assert(goalMinPassed != null);
    assert(underMin != null);
    assert(emailHasSpaceBeginning != null);
    assert(missingDotAfterExt != null);
    return emailMissingDot(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result exceedingLength(ExceedingLength<T> value),
    Result empty(Empty<T> value),
    Result multiline(Multiline<T> value),
    Result invalidNumber(InvalidNumber<T> value),
    Result numberToLow(NumberToLow<T> value),
    Result numberToBig(NumberToBig<T> value),
    Result invalidEmail(InvalidEmail<T> value),
    Result emailMissingDot(EmailMissingDot<T> value),
    Result emailHasSpace(EmailHasSpace<T> value),
    Result invalidPassword(InvalidPassword<T> value),
    Result invalidPhoneNumber(InvalidPhoneNumber<T> value),
    Result phoneNumberNotStartsWith3(PhoneNumberNotStartsWith3<T> value),
    Result notValidOperatorMX(NotValidOperatorMX<T> value),
    Result invalidName(InvalidName<T> value),
    Result nameTooShort(NameTooShort<T> value),
    Result nameTooLong(NameTooLong<T> value),
    Result phoneNumberToShort(PhoneNumberTooShort<T> value),
    Result goalMinPassed(GoalMinPassed<T> value),
    Result underMin(UnderMin<T> value),
    Result emailHasSpaceBeginning(EmailHasSpaceBeginning<T> value),
    Result missingDotAfterExt(MissingDotAfterExt<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (emailMissingDot != null) {
      return emailMissingDot(this);
    }
    return orElse();
  }
}

abstract class EmailMissingDot<T> implements ValueFailure<T> {
  const factory EmailMissingDot({@required T failedValue}) =
      _$EmailMissingDot<T>;

  @override
  T get failedValue;

  @override
  EmailMissingDot<T> copyWith({T failedValue});
}

class _$EmailHasSpace<T>
    with DiagnosticableTreeMixin
    implements EmailHasSpace<T> {
  const _$EmailHasSpace({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ValueFailure<$T>.emailHasSpace(failedValue: $failedValue)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ValueFailure<$T>.emailHasSpace'))
      ..add(DiagnosticsProperty('failedValue', failedValue));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is EmailHasSpace<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  _$EmailHasSpace<T> copyWith({
    Object failedValue = freezed,
  }) {
    return _$EmailHasSpace<T>(
      failedValue: failedValue == freezed ? this.failedValue : failedValue as T,
    );
  }

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required
        Result exceedingLength(@required T failedValue, @required int max),
    @required Result empty(@required T failedValue),
    @required Result multiline(@required T failedValue),
    @required Result invalidNumber(@required T failedValue),
    @required Result numberToLow(@required T failedValue),
    @required Result numberToBig(@required T failedValue),
    @required Result invalidEmail(@required T failedValue),
    @required Result emailMissingDot(@required T failedValue),
    @required Result emailHasSpace(@required T failedValue),
    @required Result invalidPassword(@required T failedValue),
    @required Result invalidPhoneNumber(@required T failedValue),
    @required Result phoneNumberNotStartsWith3(@required T failedValue),
    @required Result notValidOperatorMX(@required T failedValue),
    @required Result invalidName(@required T failedValue),
    @required Result nameTooShort(@required T failedValue),
    @required Result nameTooLong(@required T failedValue),
    @required Result phoneNumberToShort(@required T failedValue),
    @required Result goalMinPassed(@required T failedValue),
    @required Result underMin(@required T failedValue),
    @required Result emailHasSpaceBeginning(@required T failedValue),
    @required Result missingDotAfterExt(@required T failedValue),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(invalidNumber != null);
    assert(numberToLow != null);
    assert(numberToBig != null);
    assert(invalidEmail != null);
    assert(emailMissingDot != null);
    assert(emailHasSpace != null);
    assert(invalidPassword != null);
    assert(invalidPhoneNumber != null);
    assert(phoneNumberNotStartsWith3 != null);
    assert(notValidOperatorMX != null);
    assert(invalidName != null);
    assert(nameTooShort != null);
    assert(nameTooLong != null);
    assert(phoneNumberToShort != null);
    assert(goalMinPassed != null);
    assert(underMin != null);
    assert(emailHasSpaceBeginning != null);
    assert(missingDotAfterExt != null);
    return emailHasSpace(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result exceedingLength(@required T failedValue, @required int max),
    Result empty(@required T failedValue),
    Result multiline(@required T failedValue),
    Result invalidNumber(@required T failedValue),
    Result numberToLow(@required T failedValue),
    Result numberToBig(@required T failedValue),
    Result invalidEmail(@required T failedValue),
    Result emailMissingDot(@required T failedValue),
    Result emailHasSpace(@required T failedValue),
    Result invalidPassword(@required T failedValue),
    Result invalidPhoneNumber(@required T failedValue),
    Result phoneNumberNotStartsWith3(@required T failedValue),
    Result notValidOperatorMX(@required T failedValue),
    Result invalidName(@required T failedValue),
    Result nameTooShort(@required T failedValue),
    Result nameTooLong(@required T failedValue),
    Result phoneNumberToShort(@required T failedValue),
    Result goalMinPassed(@required T failedValue),
    Result underMin(@required T failedValue),
    Result emailHasSpaceBeginning(@required T failedValue),
    Result missingDotAfterExt(@required T failedValue),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (emailHasSpace != null) {
      return emailHasSpace(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result exceedingLength(ExceedingLength<T> value),
    @required Result empty(Empty<T> value),
    @required Result multiline(Multiline<T> value),
    @required Result invalidNumber(InvalidNumber<T> value),
    @required Result numberToLow(NumberToLow<T> value),
    @required Result numberToBig(NumberToBig<T> value),
    @required Result invalidEmail(InvalidEmail<T> value),
    @required Result emailMissingDot(EmailMissingDot<T> value),
    @required Result emailHasSpace(EmailHasSpace<T> value),
    @required Result invalidPassword(InvalidPassword<T> value),
    @required Result invalidPhoneNumber(InvalidPhoneNumber<T> value),
    @required
        Result phoneNumberNotStartsWith3(PhoneNumberNotStartsWith3<T> value),
    @required Result notValidOperatorMX(NotValidOperatorMX<T> value),
    @required Result invalidName(InvalidName<T> value),
    @required Result nameTooShort(NameTooShort<T> value),
    @required Result nameTooLong(NameTooLong<T> value),
    @required Result phoneNumberToShort(PhoneNumberTooShort<T> value),
    @required Result goalMinPassed(GoalMinPassed<T> value),
    @required Result underMin(UnderMin<T> value),
    @required Result emailHasSpaceBeginning(EmailHasSpaceBeginning<T> value),
    @required Result missingDotAfterExt(MissingDotAfterExt<T> value),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(invalidNumber != null);
    assert(numberToLow != null);
    assert(numberToBig != null);
    assert(invalidEmail != null);
    assert(emailMissingDot != null);
    assert(emailHasSpace != null);
    assert(invalidPassword != null);
    assert(invalidPhoneNumber != null);
    assert(phoneNumberNotStartsWith3 != null);
    assert(notValidOperatorMX != null);
    assert(invalidName != null);
    assert(nameTooShort != null);
    assert(nameTooLong != null);
    assert(phoneNumberToShort != null);
    assert(goalMinPassed != null);
    assert(underMin != null);
    assert(emailHasSpaceBeginning != null);
    assert(missingDotAfterExt != null);
    return emailHasSpace(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result exceedingLength(ExceedingLength<T> value),
    Result empty(Empty<T> value),
    Result multiline(Multiline<T> value),
    Result invalidNumber(InvalidNumber<T> value),
    Result numberToLow(NumberToLow<T> value),
    Result numberToBig(NumberToBig<T> value),
    Result invalidEmail(InvalidEmail<T> value),
    Result emailMissingDot(EmailMissingDot<T> value),
    Result emailHasSpace(EmailHasSpace<T> value),
    Result invalidPassword(InvalidPassword<T> value),
    Result invalidPhoneNumber(InvalidPhoneNumber<T> value),
    Result phoneNumberNotStartsWith3(PhoneNumberNotStartsWith3<T> value),
    Result notValidOperatorMX(NotValidOperatorMX<T> value),
    Result invalidName(InvalidName<T> value),
    Result nameTooShort(NameTooShort<T> value),
    Result nameTooLong(NameTooLong<T> value),
    Result phoneNumberToShort(PhoneNumberTooShort<T> value),
    Result goalMinPassed(GoalMinPassed<T> value),
    Result underMin(UnderMin<T> value),
    Result emailHasSpaceBeginning(EmailHasSpaceBeginning<T> value),
    Result missingDotAfterExt(MissingDotAfterExt<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (emailHasSpace != null) {
      return emailHasSpace(this);
    }
    return orElse();
  }
}

abstract class EmailHasSpace<T> implements ValueFailure<T> {
  const factory EmailHasSpace({@required T failedValue}) = _$EmailHasSpace<T>;

  @override
  T get failedValue;

  @override
  EmailHasSpace<T> copyWith({T failedValue});
}

class _$InvalidPassword<T>
    with DiagnosticableTreeMixin
    implements InvalidPassword<T> {
  const _$InvalidPassword({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ValueFailure<$T>.invalidPassword(failedValue: $failedValue)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ValueFailure<$T>.invalidPassword'))
      ..add(DiagnosticsProperty('failedValue', failedValue));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidPassword<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  _$InvalidPassword<T> copyWith({
    Object failedValue = freezed,
  }) {
    return _$InvalidPassword<T>(
      failedValue: failedValue == freezed ? this.failedValue : failedValue as T,
    );
  }

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required
        Result exceedingLength(@required T failedValue, @required int max),
    @required Result empty(@required T failedValue),
    @required Result multiline(@required T failedValue),
    @required Result invalidNumber(@required T failedValue),
    @required Result numberToLow(@required T failedValue),
    @required Result numberToBig(@required T failedValue),
    @required Result invalidEmail(@required T failedValue),
    @required Result emailMissingDot(@required T failedValue),
    @required Result emailHasSpace(@required T failedValue),
    @required Result invalidPassword(@required T failedValue),
    @required Result invalidPhoneNumber(@required T failedValue),
    @required Result phoneNumberNotStartsWith3(@required T failedValue),
    @required Result notValidOperatorMX(@required T failedValue),
    @required Result invalidName(@required T failedValue),
    @required Result nameTooShort(@required T failedValue),
    @required Result nameTooLong(@required T failedValue),
    @required Result phoneNumberToShort(@required T failedValue),
    @required Result goalMinPassed(@required T failedValue),
    @required Result underMin(@required T failedValue),
    @required Result emailHasSpaceBeginning(@required T failedValue),
    @required Result missingDotAfterExt(@required T failedValue),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(invalidNumber != null);
    assert(numberToLow != null);
    assert(numberToBig != null);
    assert(invalidEmail != null);
    assert(emailMissingDot != null);
    assert(emailHasSpace != null);
    assert(invalidPassword != null);
    assert(invalidPhoneNumber != null);
    assert(phoneNumberNotStartsWith3 != null);
    assert(notValidOperatorMX != null);
    assert(invalidName != null);
    assert(nameTooShort != null);
    assert(nameTooLong != null);
    assert(phoneNumberToShort != null);
    assert(goalMinPassed != null);
    assert(underMin != null);
    assert(emailHasSpaceBeginning != null);
    assert(missingDotAfterExt != null);
    return invalidPassword(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result exceedingLength(@required T failedValue, @required int max),
    Result empty(@required T failedValue),
    Result multiline(@required T failedValue),
    Result invalidNumber(@required T failedValue),
    Result numberToLow(@required T failedValue),
    Result numberToBig(@required T failedValue),
    Result invalidEmail(@required T failedValue),
    Result emailMissingDot(@required T failedValue),
    Result emailHasSpace(@required T failedValue),
    Result invalidPassword(@required T failedValue),
    Result invalidPhoneNumber(@required T failedValue),
    Result phoneNumberNotStartsWith3(@required T failedValue),
    Result notValidOperatorMX(@required T failedValue),
    Result invalidName(@required T failedValue),
    Result nameTooShort(@required T failedValue),
    Result nameTooLong(@required T failedValue),
    Result phoneNumberToShort(@required T failedValue),
    Result goalMinPassed(@required T failedValue),
    Result underMin(@required T failedValue),
    Result emailHasSpaceBeginning(@required T failedValue),
    Result missingDotAfterExt(@required T failedValue),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidPassword != null) {
      return invalidPassword(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result exceedingLength(ExceedingLength<T> value),
    @required Result empty(Empty<T> value),
    @required Result multiline(Multiline<T> value),
    @required Result invalidNumber(InvalidNumber<T> value),
    @required Result numberToLow(NumberToLow<T> value),
    @required Result numberToBig(NumberToBig<T> value),
    @required Result invalidEmail(InvalidEmail<T> value),
    @required Result emailMissingDot(EmailMissingDot<T> value),
    @required Result emailHasSpace(EmailHasSpace<T> value),
    @required Result invalidPassword(InvalidPassword<T> value),
    @required Result invalidPhoneNumber(InvalidPhoneNumber<T> value),
    @required
        Result phoneNumberNotStartsWith3(PhoneNumberNotStartsWith3<T> value),
    @required Result notValidOperatorMX(NotValidOperatorMX<T> value),
    @required Result invalidName(InvalidName<T> value),
    @required Result nameTooShort(NameTooShort<T> value),
    @required Result nameTooLong(NameTooLong<T> value),
    @required Result phoneNumberToShort(PhoneNumberTooShort<T> value),
    @required Result goalMinPassed(GoalMinPassed<T> value),
    @required Result underMin(UnderMin<T> value),
    @required Result emailHasSpaceBeginning(EmailHasSpaceBeginning<T> value),
    @required Result missingDotAfterExt(MissingDotAfterExt<T> value),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(invalidNumber != null);
    assert(numberToLow != null);
    assert(numberToBig != null);
    assert(invalidEmail != null);
    assert(emailMissingDot != null);
    assert(emailHasSpace != null);
    assert(invalidPassword != null);
    assert(invalidPhoneNumber != null);
    assert(phoneNumberNotStartsWith3 != null);
    assert(notValidOperatorMX != null);
    assert(invalidName != null);
    assert(nameTooShort != null);
    assert(nameTooLong != null);
    assert(phoneNumberToShort != null);
    assert(goalMinPassed != null);
    assert(underMin != null);
    assert(emailHasSpaceBeginning != null);
    assert(missingDotAfterExt != null);
    return invalidPassword(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result exceedingLength(ExceedingLength<T> value),
    Result empty(Empty<T> value),
    Result multiline(Multiline<T> value),
    Result invalidNumber(InvalidNumber<T> value),
    Result numberToLow(NumberToLow<T> value),
    Result numberToBig(NumberToBig<T> value),
    Result invalidEmail(InvalidEmail<T> value),
    Result emailMissingDot(EmailMissingDot<T> value),
    Result emailHasSpace(EmailHasSpace<T> value),
    Result invalidPassword(InvalidPassword<T> value),
    Result invalidPhoneNumber(InvalidPhoneNumber<T> value),
    Result phoneNumberNotStartsWith3(PhoneNumberNotStartsWith3<T> value),
    Result notValidOperatorMX(NotValidOperatorMX<T> value),
    Result invalidName(InvalidName<T> value),
    Result nameTooShort(NameTooShort<T> value),
    Result nameTooLong(NameTooLong<T> value),
    Result phoneNumberToShort(PhoneNumberTooShort<T> value),
    Result goalMinPassed(GoalMinPassed<T> value),
    Result underMin(UnderMin<T> value),
    Result emailHasSpaceBeginning(EmailHasSpaceBeginning<T> value),
    Result missingDotAfterExt(MissingDotAfterExt<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidPassword != null) {
      return invalidPassword(this);
    }
    return orElse();
  }
}

abstract class InvalidPassword<T> implements ValueFailure<T> {
  const factory InvalidPassword({@required T failedValue}) =
      _$InvalidPassword<T>;

  @override
  T get failedValue;

  @override
  InvalidPassword<T> copyWith({T failedValue});
}

class _$InvalidPhoneNumber<T>
    with DiagnosticableTreeMixin
    implements InvalidPhoneNumber<T> {
  const _$InvalidPhoneNumber({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ValueFailure<$T>.invalidPhoneNumber(failedValue: $failedValue)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ValueFailure<$T>.invalidPhoneNumber'))
      ..add(DiagnosticsProperty('failedValue', failedValue));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidPhoneNumber<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  _$InvalidPhoneNumber<T> copyWith({
    Object failedValue = freezed,
  }) {
    return _$InvalidPhoneNumber<T>(
      failedValue: failedValue == freezed ? this.failedValue : failedValue as T,
    );
  }

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required
        Result exceedingLength(@required T failedValue, @required int max),
    @required Result empty(@required T failedValue),
    @required Result multiline(@required T failedValue),
    @required Result invalidNumber(@required T failedValue),
    @required Result numberToLow(@required T failedValue),
    @required Result numberToBig(@required T failedValue),
    @required Result invalidEmail(@required T failedValue),
    @required Result emailMissingDot(@required T failedValue),
    @required Result emailHasSpace(@required T failedValue),
    @required Result invalidPassword(@required T failedValue),
    @required Result invalidPhoneNumber(@required T failedValue),
    @required Result phoneNumberNotStartsWith3(@required T failedValue),
    @required Result notValidOperatorMX(@required T failedValue),
    @required Result invalidName(@required T failedValue),
    @required Result nameTooShort(@required T failedValue),
    @required Result nameTooLong(@required T failedValue),
    @required Result phoneNumberToShort(@required T failedValue),
    @required Result goalMinPassed(@required T failedValue),
    @required Result underMin(@required T failedValue),
    @required Result emailHasSpaceBeginning(@required T failedValue),
    @required Result missingDotAfterExt(@required T failedValue),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(invalidNumber != null);
    assert(numberToLow != null);
    assert(numberToBig != null);
    assert(invalidEmail != null);
    assert(emailMissingDot != null);
    assert(emailHasSpace != null);
    assert(invalidPassword != null);
    assert(invalidPhoneNumber != null);
    assert(phoneNumberNotStartsWith3 != null);
    assert(notValidOperatorMX != null);
    assert(invalidName != null);
    assert(nameTooShort != null);
    assert(nameTooLong != null);
    assert(phoneNumberToShort != null);
    assert(goalMinPassed != null);
    assert(underMin != null);
    assert(emailHasSpaceBeginning != null);
    assert(missingDotAfterExt != null);
    return invalidPhoneNumber(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result exceedingLength(@required T failedValue, @required int max),
    Result empty(@required T failedValue),
    Result multiline(@required T failedValue),
    Result invalidNumber(@required T failedValue),
    Result numberToLow(@required T failedValue),
    Result numberToBig(@required T failedValue),
    Result invalidEmail(@required T failedValue),
    Result emailMissingDot(@required T failedValue),
    Result emailHasSpace(@required T failedValue),
    Result invalidPassword(@required T failedValue),
    Result invalidPhoneNumber(@required T failedValue),
    Result phoneNumberNotStartsWith3(@required T failedValue),
    Result notValidOperatorMX(@required T failedValue),
    Result invalidName(@required T failedValue),
    Result nameTooShort(@required T failedValue),
    Result nameTooLong(@required T failedValue),
    Result phoneNumberToShort(@required T failedValue),
    Result goalMinPassed(@required T failedValue),
    Result underMin(@required T failedValue),
    Result emailHasSpaceBeginning(@required T failedValue),
    Result missingDotAfterExt(@required T failedValue),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidPhoneNumber != null) {
      return invalidPhoneNumber(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result exceedingLength(ExceedingLength<T> value),
    @required Result empty(Empty<T> value),
    @required Result multiline(Multiline<T> value),
    @required Result invalidNumber(InvalidNumber<T> value),
    @required Result numberToLow(NumberToLow<T> value),
    @required Result numberToBig(NumberToBig<T> value),
    @required Result invalidEmail(InvalidEmail<T> value),
    @required Result emailMissingDot(EmailMissingDot<T> value),
    @required Result emailHasSpace(EmailHasSpace<T> value),
    @required Result invalidPassword(InvalidPassword<T> value),
    @required Result invalidPhoneNumber(InvalidPhoneNumber<T> value),
    @required
        Result phoneNumberNotStartsWith3(PhoneNumberNotStartsWith3<T> value),
    @required Result notValidOperatorMX(NotValidOperatorMX<T> value),
    @required Result invalidName(InvalidName<T> value),
    @required Result nameTooShort(NameTooShort<T> value),
    @required Result nameTooLong(NameTooLong<T> value),
    @required Result phoneNumberToShort(PhoneNumberTooShort<T> value),
    @required Result goalMinPassed(GoalMinPassed<T> value),
    @required Result underMin(UnderMin<T> value),
    @required Result emailHasSpaceBeginning(EmailHasSpaceBeginning<T> value),
    @required Result missingDotAfterExt(MissingDotAfterExt<T> value),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(invalidNumber != null);
    assert(numberToLow != null);
    assert(numberToBig != null);
    assert(invalidEmail != null);
    assert(emailMissingDot != null);
    assert(emailHasSpace != null);
    assert(invalidPassword != null);
    assert(invalidPhoneNumber != null);
    assert(phoneNumberNotStartsWith3 != null);
    assert(notValidOperatorMX != null);
    assert(invalidName != null);
    assert(nameTooShort != null);
    assert(nameTooLong != null);
    assert(phoneNumberToShort != null);
    assert(goalMinPassed != null);
    assert(underMin != null);
    assert(emailHasSpaceBeginning != null);
    assert(missingDotAfterExt != null);
    return invalidPhoneNumber(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result exceedingLength(ExceedingLength<T> value),
    Result empty(Empty<T> value),
    Result multiline(Multiline<T> value),
    Result invalidNumber(InvalidNumber<T> value),
    Result numberToLow(NumberToLow<T> value),
    Result numberToBig(NumberToBig<T> value),
    Result invalidEmail(InvalidEmail<T> value),
    Result emailMissingDot(EmailMissingDot<T> value),
    Result emailHasSpace(EmailHasSpace<T> value),
    Result invalidPassword(InvalidPassword<T> value),
    Result invalidPhoneNumber(InvalidPhoneNumber<T> value),
    Result phoneNumberNotStartsWith3(PhoneNumberNotStartsWith3<T> value),
    Result notValidOperatorMX(NotValidOperatorMX<T> value),
    Result invalidName(InvalidName<T> value),
    Result nameTooShort(NameTooShort<T> value),
    Result nameTooLong(NameTooLong<T> value),
    Result phoneNumberToShort(PhoneNumberTooShort<T> value),
    Result goalMinPassed(GoalMinPassed<T> value),
    Result underMin(UnderMin<T> value),
    Result emailHasSpaceBeginning(EmailHasSpaceBeginning<T> value),
    Result missingDotAfterExt(MissingDotAfterExt<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidPhoneNumber != null) {
      return invalidPhoneNumber(this);
    }
    return orElse();
  }
}

abstract class InvalidPhoneNumber<T> implements ValueFailure<T> {
  const factory InvalidPhoneNumber({@required T failedValue}) =
      _$InvalidPhoneNumber<T>;

  @override
  T get failedValue;

  @override
  InvalidPhoneNumber<T> copyWith({T failedValue});
}

class _$PhoneNumberNotStartsWith3<T>
    with DiagnosticableTreeMixin
    implements PhoneNumberNotStartsWith3<T> {
  const _$PhoneNumberNotStartsWith3({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ValueFailure<$T>.phoneNumberNotStartsWith3(failedValue: $failedValue)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty(
          'type', 'ValueFailure<$T>.phoneNumberNotStartsWith3'))
      ..add(DiagnosticsProperty('failedValue', failedValue));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PhoneNumberNotStartsWith3<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  _$PhoneNumberNotStartsWith3<T> copyWith({
    Object failedValue = freezed,
  }) {
    return _$PhoneNumberNotStartsWith3<T>(
      failedValue: failedValue == freezed ? this.failedValue : failedValue as T,
    );
  }

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required
        Result exceedingLength(@required T failedValue, @required int max),
    @required Result empty(@required T failedValue),
    @required Result multiline(@required T failedValue),
    @required Result invalidNumber(@required T failedValue),
    @required Result numberToLow(@required T failedValue),
    @required Result numberToBig(@required T failedValue),
    @required Result invalidEmail(@required T failedValue),
    @required Result emailMissingDot(@required T failedValue),
    @required Result emailHasSpace(@required T failedValue),
    @required Result invalidPassword(@required T failedValue),
    @required Result invalidPhoneNumber(@required T failedValue),
    @required Result phoneNumberNotStartsWith3(@required T failedValue),
    @required Result notValidOperatorMX(@required T failedValue),
    @required Result invalidName(@required T failedValue),
    @required Result nameTooShort(@required T failedValue),
    @required Result nameTooLong(@required T failedValue),
    @required Result phoneNumberToShort(@required T failedValue),
    @required Result goalMinPassed(@required T failedValue),
    @required Result underMin(@required T failedValue),
    @required Result emailHasSpaceBeginning(@required T failedValue),
    @required Result missingDotAfterExt(@required T failedValue),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(invalidNumber != null);
    assert(numberToLow != null);
    assert(numberToBig != null);
    assert(invalidEmail != null);
    assert(emailMissingDot != null);
    assert(emailHasSpace != null);
    assert(invalidPassword != null);
    assert(invalidPhoneNumber != null);
    assert(phoneNumberNotStartsWith3 != null);
    assert(notValidOperatorMX != null);
    assert(invalidName != null);
    assert(nameTooShort != null);
    assert(nameTooLong != null);
    assert(phoneNumberToShort != null);
    assert(goalMinPassed != null);
    assert(underMin != null);
    assert(emailHasSpaceBeginning != null);
    assert(missingDotAfterExt != null);
    return phoneNumberNotStartsWith3(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result exceedingLength(@required T failedValue, @required int max),
    Result empty(@required T failedValue),
    Result multiline(@required T failedValue),
    Result invalidNumber(@required T failedValue),
    Result numberToLow(@required T failedValue),
    Result numberToBig(@required T failedValue),
    Result invalidEmail(@required T failedValue),
    Result emailMissingDot(@required T failedValue),
    Result emailHasSpace(@required T failedValue),
    Result invalidPassword(@required T failedValue),
    Result invalidPhoneNumber(@required T failedValue),
    Result phoneNumberNotStartsWith3(@required T failedValue),
    Result notValidOperatorMX(@required T failedValue),
    Result invalidName(@required T failedValue),
    Result nameTooShort(@required T failedValue),
    Result nameTooLong(@required T failedValue),
    Result phoneNumberToShort(@required T failedValue),
    Result goalMinPassed(@required T failedValue),
    Result underMin(@required T failedValue),
    Result emailHasSpaceBeginning(@required T failedValue),
    Result missingDotAfterExt(@required T failedValue),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (phoneNumberNotStartsWith3 != null) {
      return phoneNumberNotStartsWith3(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result exceedingLength(ExceedingLength<T> value),
    @required Result empty(Empty<T> value),
    @required Result multiline(Multiline<T> value),
    @required Result invalidNumber(InvalidNumber<T> value),
    @required Result numberToLow(NumberToLow<T> value),
    @required Result numberToBig(NumberToBig<T> value),
    @required Result invalidEmail(InvalidEmail<T> value),
    @required Result emailMissingDot(EmailMissingDot<T> value),
    @required Result emailHasSpace(EmailHasSpace<T> value),
    @required Result invalidPassword(InvalidPassword<T> value),
    @required Result invalidPhoneNumber(InvalidPhoneNumber<T> value),
    @required
        Result phoneNumberNotStartsWith3(PhoneNumberNotStartsWith3<T> value),
    @required Result notValidOperatorMX(NotValidOperatorMX<T> value),
    @required Result invalidName(InvalidName<T> value),
    @required Result nameTooShort(NameTooShort<T> value),
    @required Result nameTooLong(NameTooLong<T> value),
    @required Result phoneNumberToShort(PhoneNumberTooShort<T> value),
    @required Result goalMinPassed(GoalMinPassed<T> value),
    @required Result underMin(UnderMin<T> value),
    @required Result emailHasSpaceBeginning(EmailHasSpaceBeginning<T> value),
    @required Result missingDotAfterExt(MissingDotAfterExt<T> value),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(invalidNumber != null);
    assert(numberToLow != null);
    assert(numberToBig != null);
    assert(invalidEmail != null);
    assert(emailMissingDot != null);
    assert(emailHasSpace != null);
    assert(invalidPassword != null);
    assert(invalidPhoneNumber != null);
    assert(phoneNumberNotStartsWith3 != null);
    assert(notValidOperatorMX != null);
    assert(invalidName != null);
    assert(nameTooShort != null);
    assert(nameTooLong != null);
    assert(phoneNumberToShort != null);
    assert(goalMinPassed != null);
    assert(underMin != null);
    assert(emailHasSpaceBeginning != null);
    assert(missingDotAfterExt != null);
    return phoneNumberNotStartsWith3(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result exceedingLength(ExceedingLength<T> value),
    Result empty(Empty<T> value),
    Result multiline(Multiline<T> value),
    Result invalidNumber(InvalidNumber<T> value),
    Result numberToLow(NumberToLow<T> value),
    Result numberToBig(NumberToBig<T> value),
    Result invalidEmail(InvalidEmail<T> value),
    Result emailMissingDot(EmailMissingDot<T> value),
    Result emailHasSpace(EmailHasSpace<T> value),
    Result invalidPassword(InvalidPassword<T> value),
    Result invalidPhoneNumber(InvalidPhoneNumber<T> value),
    Result phoneNumberNotStartsWith3(PhoneNumberNotStartsWith3<T> value),
    Result notValidOperatorMX(NotValidOperatorMX<T> value),
    Result invalidName(InvalidName<T> value),
    Result nameTooShort(NameTooShort<T> value),
    Result nameTooLong(NameTooLong<T> value),
    Result phoneNumberToShort(PhoneNumberTooShort<T> value),
    Result goalMinPassed(GoalMinPassed<T> value),
    Result underMin(UnderMin<T> value),
    Result emailHasSpaceBeginning(EmailHasSpaceBeginning<T> value),
    Result missingDotAfterExt(MissingDotAfterExt<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (phoneNumberNotStartsWith3 != null) {
      return phoneNumberNotStartsWith3(this);
    }
    return orElse();
  }
}

abstract class PhoneNumberNotStartsWith3<T> implements ValueFailure<T> {
  const factory PhoneNumberNotStartsWith3({@required T failedValue}) =
      _$PhoneNumberNotStartsWith3<T>;

  @override
  T get failedValue;

  @override
  PhoneNumberNotStartsWith3<T> copyWith({T failedValue});
}

class _$NotValidOperatorMX<T>
    with DiagnosticableTreeMixin
    implements NotValidOperatorMX<T> {
  const _$NotValidOperatorMX({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ValueFailure<$T>.notValidOperatorMX(failedValue: $failedValue)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ValueFailure<$T>.notValidOperatorMX'))
      ..add(DiagnosticsProperty('failedValue', failedValue));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is NotValidOperatorMX<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  _$NotValidOperatorMX<T> copyWith({
    Object failedValue = freezed,
  }) {
    return _$NotValidOperatorMX<T>(
      failedValue: failedValue == freezed ? this.failedValue : failedValue as T,
    );
  }

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required
        Result exceedingLength(@required T failedValue, @required int max),
    @required Result empty(@required T failedValue),
    @required Result multiline(@required T failedValue),
    @required Result invalidNumber(@required T failedValue),
    @required Result numberToLow(@required T failedValue),
    @required Result numberToBig(@required T failedValue),
    @required Result invalidEmail(@required T failedValue),
    @required Result emailMissingDot(@required T failedValue),
    @required Result emailHasSpace(@required T failedValue),
    @required Result invalidPassword(@required T failedValue),
    @required Result invalidPhoneNumber(@required T failedValue),
    @required Result phoneNumberNotStartsWith3(@required T failedValue),
    @required Result notValidOperatorMX(@required T failedValue),
    @required Result invalidName(@required T failedValue),
    @required Result nameTooShort(@required T failedValue),
    @required Result nameTooLong(@required T failedValue),
    @required Result phoneNumberToShort(@required T failedValue),
    @required Result goalMinPassed(@required T failedValue),
    @required Result underMin(@required T failedValue),
    @required Result emailHasSpaceBeginning(@required T failedValue),
    @required Result missingDotAfterExt(@required T failedValue),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(invalidNumber != null);
    assert(numberToLow != null);
    assert(numberToBig != null);
    assert(invalidEmail != null);
    assert(emailMissingDot != null);
    assert(emailHasSpace != null);
    assert(invalidPassword != null);
    assert(invalidPhoneNumber != null);
    assert(phoneNumberNotStartsWith3 != null);
    assert(notValidOperatorMX != null);
    assert(invalidName != null);
    assert(nameTooShort != null);
    assert(nameTooLong != null);
    assert(phoneNumberToShort != null);
    assert(goalMinPassed != null);
    assert(underMin != null);
    assert(emailHasSpaceBeginning != null);
    assert(missingDotAfterExt != null);
    return notValidOperatorMX(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result exceedingLength(@required T failedValue, @required int max),
    Result empty(@required T failedValue),
    Result multiline(@required T failedValue),
    Result invalidNumber(@required T failedValue),
    Result numberToLow(@required T failedValue),
    Result numberToBig(@required T failedValue),
    Result invalidEmail(@required T failedValue),
    Result emailMissingDot(@required T failedValue),
    Result emailHasSpace(@required T failedValue),
    Result invalidPassword(@required T failedValue),
    Result invalidPhoneNumber(@required T failedValue),
    Result phoneNumberNotStartsWith3(@required T failedValue),
    Result notValidOperatorMX(@required T failedValue),
    Result invalidName(@required T failedValue),
    Result nameTooShort(@required T failedValue),
    Result nameTooLong(@required T failedValue),
    Result phoneNumberToShort(@required T failedValue),
    Result goalMinPassed(@required T failedValue),
    Result underMin(@required T failedValue),
    Result emailHasSpaceBeginning(@required T failedValue),
    Result missingDotAfterExt(@required T failedValue),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (notValidOperatorMX != null) {
      return notValidOperatorMX(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result exceedingLength(ExceedingLength<T> value),
    @required Result empty(Empty<T> value),
    @required Result multiline(Multiline<T> value),
    @required Result invalidNumber(InvalidNumber<T> value),
    @required Result numberToLow(NumberToLow<T> value),
    @required Result numberToBig(NumberToBig<T> value),
    @required Result invalidEmail(InvalidEmail<T> value),
    @required Result emailMissingDot(EmailMissingDot<T> value),
    @required Result emailHasSpace(EmailHasSpace<T> value),
    @required Result invalidPassword(InvalidPassword<T> value),
    @required Result invalidPhoneNumber(InvalidPhoneNumber<T> value),
    @required
        Result phoneNumberNotStartsWith3(PhoneNumberNotStartsWith3<T> value),
    @required Result notValidOperatorMX(NotValidOperatorMX<T> value),
    @required Result invalidName(InvalidName<T> value),
    @required Result nameTooShort(NameTooShort<T> value),
    @required Result nameTooLong(NameTooLong<T> value),
    @required Result phoneNumberToShort(PhoneNumberTooShort<T> value),
    @required Result goalMinPassed(GoalMinPassed<T> value),
    @required Result underMin(UnderMin<T> value),
    @required Result emailHasSpaceBeginning(EmailHasSpaceBeginning<T> value),
    @required Result missingDotAfterExt(MissingDotAfterExt<T> value),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(invalidNumber != null);
    assert(numberToLow != null);
    assert(numberToBig != null);
    assert(invalidEmail != null);
    assert(emailMissingDot != null);
    assert(emailHasSpace != null);
    assert(invalidPassword != null);
    assert(invalidPhoneNumber != null);
    assert(phoneNumberNotStartsWith3 != null);
    assert(notValidOperatorMX != null);
    assert(invalidName != null);
    assert(nameTooShort != null);
    assert(nameTooLong != null);
    assert(phoneNumberToShort != null);
    assert(goalMinPassed != null);
    assert(underMin != null);
    assert(emailHasSpaceBeginning != null);
    assert(missingDotAfterExt != null);
    return notValidOperatorMX(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result exceedingLength(ExceedingLength<T> value),
    Result empty(Empty<T> value),
    Result multiline(Multiline<T> value),
    Result invalidNumber(InvalidNumber<T> value),
    Result numberToLow(NumberToLow<T> value),
    Result numberToBig(NumberToBig<T> value),
    Result invalidEmail(InvalidEmail<T> value),
    Result emailMissingDot(EmailMissingDot<T> value),
    Result emailHasSpace(EmailHasSpace<T> value),
    Result invalidPassword(InvalidPassword<T> value),
    Result invalidPhoneNumber(InvalidPhoneNumber<T> value),
    Result phoneNumberNotStartsWith3(PhoneNumberNotStartsWith3<T> value),
    Result notValidOperatorMX(NotValidOperatorMX<T> value),
    Result invalidName(InvalidName<T> value),
    Result nameTooShort(NameTooShort<T> value),
    Result nameTooLong(NameTooLong<T> value),
    Result phoneNumberToShort(PhoneNumberTooShort<T> value),
    Result goalMinPassed(GoalMinPassed<T> value),
    Result underMin(UnderMin<T> value),
    Result emailHasSpaceBeginning(EmailHasSpaceBeginning<T> value),
    Result missingDotAfterExt(MissingDotAfterExt<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (notValidOperatorMX != null) {
      return notValidOperatorMX(this);
    }
    return orElse();
  }
}

abstract class NotValidOperatorMX<T> implements ValueFailure<T> {
  const factory NotValidOperatorMX({@required T failedValue}) =
      _$NotValidOperatorMX<T>;

  @override
  T get failedValue;

  @override
  NotValidOperatorMX<T> copyWith({T failedValue});
}

class _$InvalidName<T> with DiagnosticableTreeMixin implements InvalidName<T> {
  const _$InvalidName({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ValueFailure<$T>.invalidName(failedValue: $failedValue)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ValueFailure<$T>.invalidName'))
      ..add(DiagnosticsProperty('failedValue', failedValue));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidName<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  _$InvalidName<T> copyWith({
    Object failedValue = freezed,
  }) {
    return _$InvalidName<T>(
      failedValue: failedValue == freezed ? this.failedValue : failedValue as T,
    );
  }

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required
        Result exceedingLength(@required T failedValue, @required int max),
    @required Result empty(@required T failedValue),
    @required Result multiline(@required T failedValue),
    @required Result invalidNumber(@required T failedValue),
    @required Result numberToLow(@required T failedValue),
    @required Result numberToBig(@required T failedValue),
    @required Result invalidEmail(@required T failedValue),
    @required Result emailMissingDot(@required T failedValue),
    @required Result emailHasSpace(@required T failedValue),
    @required Result invalidPassword(@required T failedValue),
    @required Result invalidPhoneNumber(@required T failedValue),
    @required Result phoneNumberNotStartsWith3(@required T failedValue),
    @required Result notValidOperatorMX(@required T failedValue),
    @required Result invalidName(@required T failedValue),
    @required Result nameTooShort(@required T failedValue),
    @required Result nameTooLong(@required T failedValue),
    @required Result phoneNumberToShort(@required T failedValue),
    @required Result goalMinPassed(@required T failedValue),
    @required Result underMin(@required T failedValue),
    @required Result emailHasSpaceBeginning(@required T failedValue),
    @required Result missingDotAfterExt(@required T failedValue),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(invalidNumber != null);
    assert(numberToLow != null);
    assert(numberToBig != null);
    assert(invalidEmail != null);
    assert(emailMissingDot != null);
    assert(emailHasSpace != null);
    assert(invalidPassword != null);
    assert(invalidPhoneNumber != null);
    assert(phoneNumberNotStartsWith3 != null);
    assert(notValidOperatorMX != null);
    assert(invalidName != null);
    assert(nameTooShort != null);
    assert(nameTooLong != null);
    assert(phoneNumberToShort != null);
    assert(goalMinPassed != null);
    assert(underMin != null);
    assert(emailHasSpaceBeginning != null);
    assert(missingDotAfterExt != null);
    return invalidName(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result exceedingLength(@required T failedValue, @required int max),
    Result empty(@required T failedValue),
    Result multiline(@required T failedValue),
    Result invalidNumber(@required T failedValue),
    Result numberToLow(@required T failedValue),
    Result numberToBig(@required T failedValue),
    Result invalidEmail(@required T failedValue),
    Result emailMissingDot(@required T failedValue),
    Result emailHasSpace(@required T failedValue),
    Result invalidPassword(@required T failedValue),
    Result invalidPhoneNumber(@required T failedValue),
    Result phoneNumberNotStartsWith3(@required T failedValue),
    Result notValidOperatorMX(@required T failedValue),
    Result invalidName(@required T failedValue),
    Result nameTooShort(@required T failedValue),
    Result nameTooLong(@required T failedValue),
    Result phoneNumberToShort(@required T failedValue),
    Result goalMinPassed(@required T failedValue),
    Result underMin(@required T failedValue),
    Result emailHasSpaceBeginning(@required T failedValue),
    Result missingDotAfterExt(@required T failedValue),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidName != null) {
      return invalidName(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result exceedingLength(ExceedingLength<T> value),
    @required Result empty(Empty<T> value),
    @required Result multiline(Multiline<T> value),
    @required Result invalidNumber(InvalidNumber<T> value),
    @required Result numberToLow(NumberToLow<T> value),
    @required Result numberToBig(NumberToBig<T> value),
    @required Result invalidEmail(InvalidEmail<T> value),
    @required Result emailMissingDot(EmailMissingDot<T> value),
    @required Result emailHasSpace(EmailHasSpace<T> value),
    @required Result invalidPassword(InvalidPassword<T> value),
    @required Result invalidPhoneNumber(InvalidPhoneNumber<T> value),
    @required
        Result phoneNumberNotStartsWith3(PhoneNumberNotStartsWith3<T> value),
    @required Result notValidOperatorMX(NotValidOperatorMX<T> value),
    @required Result invalidName(InvalidName<T> value),
    @required Result nameTooShort(NameTooShort<T> value),
    @required Result nameTooLong(NameTooLong<T> value),
    @required Result phoneNumberToShort(PhoneNumberTooShort<T> value),
    @required Result goalMinPassed(GoalMinPassed<T> value),
    @required Result underMin(UnderMin<T> value),
    @required Result emailHasSpaceBeginning(EmailHasSpaceBeginning<T> value),
    @required Result missingDotAfterExt(MissingDotAfterExt<T> value),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(invalidNumber != null);
    assert(numberToLow != null);
    assert(numberToBig != null);
    assert(invalidEmail != null);
    assert(emailMissingDot != null);
    assert(emailHasSpace != null);
    assert(invalidPassword != null);
    assert(invalidPhoneNumber != null);
    assert(phoneNumberNotStartsWith3 != null);
    assert(notValidOperatorMX != null);
    assert(invalidName != null);
    assert(nameTooShort != null);
    assert(nameTooLong != null);
    assert(phoneNumberToShort != null);
    assert(goalMinPassed != null);
    assert(underMin != null);
    assert(emailHasSpaceBeginning != null);
    assert(missingDotAfterExt != null);
    return invalidName(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result exceedingLength(ExceedingLength<T> value),
    Result empty(Empty<T> value),
    Result multiline(Multiline<T> value),
    Result invalidNumber(InvalidNumber<T> value),
    Result numberToLow(NumberToLow<T> value),
    Result numberToBig(NumberToBig<T> value),
    Result invalidEmail(InvalidEmail<T> value),
    Result emailMissingDot(EmailMissingDot<T> value),
    Result emailHasSpace(EmailHasSpace<T> value),
    Result invalidPassword(InvalidPassword<T> value),
    Result invalidPhoneNumber(InvalidPhoneNumber<T> value),
    Result phoneNumberNotStartsWith3(PhoneNumberNotStartsWith3<T> value),
    Result notValidOperatorMX(NotValidOperatorMX<T> value),
    Result invalidName(InvalidName<T> value),
    Result nameTooShort(NameTooShort<T> value),
    Result nameTooLong(NameTooLong<T> value),
    Result phoneNumberToShort(PhoneNumberTooShort<T> value),
    Result goalMinPassed(GoalMinPassed<T> value),
    Result underMin(UnderMin<T> value),
    Result emailHasSpaceBeginning(EmailHasSpaceBeginning<T> value),
    Result missingDotAfterExt(MissingDotAfterExt<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidName != null) {
      return invalidName(this);
    }
    return orElse();
  }
}

abstract class InvalidName<T> implements ValueFailure<T> {
  const factory InvalidName({@required T failedValue}) = _$InvalidName<T>;

  @override
  T get failedValue;

  @override
  InvalidName<T> copyWith({T failedValue});
}

class _$NameTooShort<T>
    with DiagnosticableTreeMixin
    implements NameTooShort<T> {
  const _$NameTooShort({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ValueFailure<$T>.nameTooShort(failedValue: $failedValue)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ValueFailure<$T>.nameTooShort'))
      ..add(DiagnosticsProperty('failedValue', failedValue));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is NameTooShort<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  _$NameTooShort<T> copyWith({
    Object failedValue = freezed,
  }) {
    return _$NameTooShort<T>(
      failedValue: failedValue == freezed ? this.failedValue : failedValue as T,
    );
  }

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required
        Result exceedingLength(@required T failedValue, @required int max),
    @required Result empty(@required T failedValue),
    @required Result multiline(@required T failedValue),
    @required Result invalidNumber(@required T failedValue),
    @required Result numberToLow(@required T failedValue),
    @required Result numberToBig(@required T failedValue),
    @required Result invalidEmail(@required T failedValue),
    @required Result emailMissingDot(@required T failedValue),
    @required Result emailHasSpace(@required T failedValue),
    @required Result invalidPassword(@required T failedValue),
    @required Result invalidPhoneNumber(@required T failedValue),
    @required Result phoneNumberNotStartsWith3(@required T failedValue),
    @required Result notValidOperatorMX(@required T failedValue),
    @required Result invalidName(@required T failedValue),
    @required Result nameTooShort(@required T failedValue),
    @required Result nameTooLong(@required T failedValue),
    @required Result phoneNumberToShort(@required T failedValue),
    @required Result goalMinPassed(@required T failedValue),
    @required Result underMin(@required T failedValue),
    @required Result emailHasSpaceBeginning(@required T failedValue),
    @required Result missingDotAfterExt(@required T failedValue),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(invalidNumber != null);
    assert(numberToLow != null);
    assert(numberToBig != null);
    assert(invalidEmail != null);
    assert(emailMissingDot != null);
    assert(emailHasSpace != null);
    assert(invalidPassword != null);
    assert(invalidPhoneNumber != null);
    assert(phoneNumberNotStartsWith3 != null);
    assert(notValidOperatorMX != null);
    assert(invalidName != null);
    assert(nameTooShort != null);
    assert(nameTooLong != null);
    assert(phoneNumberToShort != null);
    assert(goalMinPassed != null);
    assert(underMin != null);
    assert(emailHasSpaceBeginning != null);
    assert(missingDotAfterExt != null);
    return nameTooShort(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result exceedingLength(@required T failedValue, @required int max),
    Result empty(@required T failedValue),
    Result multiline(@required T failedValue),
    Result invalidNumber(@required T failedValue),
    Result numberToLow(@required T failedValue),
    Result numberToBig(@required T failedValue),
    Result invalidEmail(@required T failedValue),
    Result emailMissingDot(@required T failedValue),
    Result emailHasSpace(@required T failedValue),
    Result invalidPassword(@required T failedValue),
    Result invalidPhoneNumber(@required T failedValue),
    Result phoneNumberNotStartsWith3(@required T failedValue),
    Result notValidOperatorMX(@required T failedValue),
    Result invalidName(@required T failedValue),
    Result nameTooShort(@required T failedValue),
    Result nameTooLong(@required T failedValue),
    Result phoneNumberToShort(@required T failedValue),
    Result goalMinPassed(@required T failedValue),
    Result underMin(@required T failedValue),
    Result emailHasSpaceBeginning(@required T failedValue),
    Result missingDotAfterExt(@required T failedValue),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (nameTooShort != null) {
      return nameTooShort(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result exceedingLength(ExceedingLength<T> value),
    @required Result empty(Empty<T> value),
    @required Result multiline(Multiline<T> value),
    @required Result invalidNumber(InvalidNumber<T> value),
    @required Result numberToLow(NumberToLow<T> value),
    @required Result numberToBig(NumberToBig<T> value),
    @required Result invalidEmail(InvalidEmail<T> value),
    @required Result emailMissingDot(EmailMissingDot<T> value),
    @required Result emailHasSpace(EmailHasSpace<T> value),
    @required Result invalidPassword(InvalidPassword<T> value),
    @required Result invalidPhoneNumber(InvalidPhoneNumber<T> value),
    @required
        Result phoneNumberNotStartsWith3(PhoneNumberNotStartsWith3<T> value),
    @required Result notValidOperatorMX(NotValidOperatorMX<T> value),
    @required Result invalidName(InvalidName<T> value),
    @required Result nameTooShort(NameTooShort<T> value),
    @required Result nameTooLong(NameTooLong<T> value),
    @required Result phoneNumberToShort(PhoneNumberTooShort<T> value),
    @required Result goalMinPassed(GoalMinPassed<T> value),
    @required Result underMin(UnderMin<T> value),
    @required Result emailHasSpaceBeginning(EmailHasSpaceBeginning<T> value),
    @required Result missingDotAfterExt(MissingDotAfterExt<T> value),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(invalidNumber != null);
    assert(numberToLow != null);
    assert(numberToBig != null);
    assert(invalidEmail != null);
    assert(emailMissingDot != null);
    assert(emailHasSpace != null);
    assert(invalidPassword != null);
    assert(invalidPhoneNumber != null);
    assert(phoneNumberNotStartsWith3 != null);
    assert(notValidOperatorMX != null);
    assert(invalidName != null);
    assert(nameTooShort != null);
    assert(nameTooLong != null);
    assert(phoneNumberToShort != null);
    assert(goalMinPassed != null);
    assert(underMin != null);
    assert(emailHasSpaceBeginning != null);
    assert(missingDotAfterExt != null);
    return nameTooShort(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result exceedingLength(ExceedingLength<T> value),
    Result empty(Empty<T> value),
    Result multiline(Multiline<T> value),
    Result invalidNumber(InvalidNumber<T> value),
    Result numberToLow(NumberToLow<T> value),
    Result numberToBig(NumberToBig<T> value),
    Result invalidEmail(InvalidEmail<T> value),
    Result emailMissingDot(EmailMissingDot<T> value),
    Result emailHasSpace(EmailHasSpace<T> value),
    Result invalidPassword(InvalidPassword<T> value),
    Result invalidPhoneNumber(InvalidPhoneNumber<T> value),
    Result phoneNumberNotStartsWith3(PhoneNumberNotStartsWith3<T> value),
    Result notValidOperatorMX(NotValidOperatorMX<T> value),
    Result invalidName(InvalidName<T> value),
    Result nameTooShort(NameTooShort<T> value),
    Result nameTooLong(NameTooLong<T> value),
    Result phoneNumberToShort(PhoneNumberTooShort<T> value),
    Result goalMinPassed(GoalMinPassed<T> value),
    Result underMin(UnderMin<T> value),
    Result emailHasSpaceBeginning(EmailHasSpaceBeginning<T> value),
    Result missingDotAfterExt(MissingDotAfterExt<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (nameTooShort != null) {
      return nameTooShort(this);
    }
    return orElse();
  }
}

abstract class NameTooShort<T> implements ValueFailure<T> {
  const factory NameTooShort({@required T failedValue}) = _$NameTooShort<T>;

  @override
  T get failedValue;

  @override
  NameTooShort<T> copyWith({T failedValue});
}

class _$NameTooLong<T> with DiagnosticableTreeMixin implements NameTooLong<T> {
  const _$NameTooLong({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ValueFailure<$T>.nameTooLong(failedValue: $failedValue)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ValueFailure<$T>.nameTooLong'))
      ..add(DiagnosticsProperty('failedValue', failedValue));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is NameTooLong<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  _$NameTooLong<T> copyWith({
    Object failedValue = freezed,
  }) {
    return _$NameTooLong<T>(
      failedValue: failedValue == freezed ? this.failedValue : failedValue as T,
    );
  }

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required
        Result exceedingLength(@required T failedValue, @required int max),
    @required Result empty(@required T failedValue),
    @required Result multiline(@required T failedValue),
    @required Result invalidNumber(@required T failedValue),
    @required Result numberToLow(@required T failedValue),
    @required Result numberToBig(@required T failedValue),
    @required Result invalidEmail(@required T failedValue),
    @required Result emailMissingDot(@required T failedValue),
    @required Result emailHasSpace(@required T failedValue),
    @required Result invalidPassword(@required T failedValue),
    @required Result invalidPhoneNumber(@required T failedValue),
    @required Result phoneNumberNotStartsWith3(@required T failedValue),
    @required Result notValidOperatorMX(@required T failedValue),
    @required Result invalidName(@required T failedValue),
    @required Result nameTooShort(@required T failedValue),
    @required Result nameTooLong(@required T failedValue),
    @required Result phoneNumberToShort(@required T failedValue),
    @required Result goalMinPassed(@required T failedValue),
    @required Result underMin(@required T failedValue),
    @required Result emailHasSpaceBeginning(@required T failedValue),
    @required Result missingDotAfterExt(@required T failedValue),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(invalidNumber != null);
    assert(numberToLow != null);
    assert(numberToBig != null);
    assert(invalidEmail != null);
    assert(emailMissingDot != null);
    assert(emailHasSpace != null);
    assert(invalidPassword != null);
    assert(invalidPhoneNumber != null);
    assert(phoneNumberNotStartsWith3 != null);
    assert(notValidOperatorMX != null);
    assert(invalidName != null);
    assert(nameTooShort != null);
    assert(nameTooLong != null);
    assert(phoneNumberToShort != null);
    assert(goalMinPassed != null);
    assert(underMin != null);
    assert(emailHasSpaceBeginning != null);
    assert(missingDotAfterExt != null);
    return nameTooLong(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result exceedingLength(@required T failedValue, @required int max),
    Result empty(@required T failedValue),
    Result multiline(@required T failedValue),
    Result invalidNumber(@required T failedValue),
    Result numberToLow(@required T failedValue),
    Result numberToBig(@required T failedValue),
    Result invalidEmail(@required T failedValue),
    Result emailMissingDot(@required T failedValue),
    Result emailHasSpace(@required T failedValue),
    Result invalidPassword(@required T failedValue),
    Result invalidPhoneNumber(@required T failedValue),
    Result phoneNumberNotStartsWith3(@required T failedValue),
    Result notValidOperatorMX(@required T failedValue),
    Result invalidName(@required T failedValue),
    Result nameTooShort(@required T failedValue),
    Result nameTooLong(@required T failedValue),
    Result phoneNumberToShort(@required T failedValue),
    Result goalMinPassed(@required T failedValue),
    Result underMin(@required T failedValue),
    Result emailHasSpaceBeginning(@required T failedValue),
    Result missingDotAfterExt(@required T failedValue),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (nameTooLong != null) {
      return nameTooLong(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result exceedingLength(ExceedingLength<T> value),
    @required Result empty(Empty<T> value),
    @required Result multiline(Multiline<T> value),
    @required Result invalidNumber(InvalidNumber<T> value),
    @required Result numberToLow(NumberToLow<T> value),
    @required Result numberToBig(NumberToBig<T> value),
    @required Result invalidEmail(InvalidEmail<T> value),
    @required Result emailMissingDot(EmailMissingDot<T> value),
    @required Result emailHasSpace(EmailHasSpace<T> value),
    @required Result invalidPassword(InvalidPassword<T> value),
    @required Result invalidPhoneNumber(InvalidPhoneNumber<T> value),
    @required
        Result phoneNumberNotStartsWith3(PhoneNumberNotStartsWith3<T> value),
    @required Result notValidOperatorMX(NotValidOperatorMX<T> value),
    @required Result invalidName(InvalidName<T> value),
    @required Result nameTooShort(NameTooShort<T> value),
    @required Result nameTooLong(NameTooLong<T> value),
    @required Result phoneNumberToShort(PhoneNumberTooShort<T> value),
    @required Result goalMinPassed(GoalMinPassed<T> value),
    @required Result underMin(UnderMin<T> value),
    @required Result emailHasSpaceBeginning(EmailHasSpaceBeginning<T> value),
    @required Result missingDotAfterExt(MissingDotAfterExt<T> value),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(invalidNumber != null);
    assert(numberToLow != null);
    assert(numberToBig != null);
    assert(invalidEmail != null);
    assert(emailMissingDot != null);
    assert(emailHasSpace != null);
    assert(invalidPassword != null);
    assert(invalidPhoneNumber != null);
    assert(phoneNumberNotStartsWith3 != null);
    assert(notValidOperatorMX != null);
    assert(invalidName != null);
    assert(nameTooShort != null);
    assert(nameTooLong != null);
    assert(phoneNumberToShort != null);
    assert(goalMinPassed != null);
    assert(underMin != null);
    assert(emailHasSpaceBeginning != null);
    assert(missingDotAfterExt != null);
    return nameTooLong(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result exceedingLength(ExceedingLength<T> value),
    Result empty(Empty<T> value),
    Result multiline(Multiline<T> value),
    Result invalidNumber(InvalidNumber<T> value),
    Result numberToLow(NumberToLow<T> value),
    Result numberToBig(NumberToBig<T> value),
    Result invalidEmail(InvalidEmail<T> value),
    Result emailMissingDot(EmailMissingDot<T> value),
    Result emailHasSpace(EmailHasSpace<T> value),
    Result invalidPassword(InvalidPassword<T> value),
    Result invalidPhoneNumber(InvalidPhoneNumber<T> value),
    Result phoneNumberNotStartsWith3(PhoneNumberNotStartsWith3<T> value),
    Result notValidOperatorMX(NotValidOperatorMX<T> value),
    Result invalidName(InvalidName<T> value),
    Result nameTooShort(NameTooShort<T> value),
    Result nameTooLong(NameTooLong<T> value),
    Result phoneNumberToShort(PhoneNumberTooShort<T> value),
    Result goalMinPassed(GoalMinPassed<T> value),
    Result underMin(UnderMin<T> value),
    Result emailHasSpaceBeginning(EmailHasSpaceBeginning<T> value),
    Result missingDotAfterExt(MissingDotAfterExt<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (nameTooLong != null) {
      return nameTooLong(this);
    }
    return orElse();
  }
}

abstract class NameTooLong<T> implements ValueFailure<T> {
  const factory NameTooLong({@required T failedValue}) = _$NameTooLong<T>;

  @override
  T get failedValue;

  @override
  NameTooLong<T> copyWith({T failedValue});
}

class _$PhoneNumberTooShort<T>
    with DiagnosticableTreeMixin
    implements PhoneNumberTooShort<T> {
  const _$PhoneNumberTooShort({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ValueFailure<$T>.phoneNumberToShort(failedValue: $failedValue)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ValueFailure<$T>.phoneNumberToShort'))
      ..add(DiagnosticsProperty('failedValue', failedValue));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PhoneNumberTooShort<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  _$PhoneNumberTooShort<T> copyWith({
    Object failedValue = freezed,
  }) {
    return _$PhoneNumberTooShort<T>(
      failedValue: failedValue == freezed ? this.failedValue : failedValue as T,
    );
  }

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required
        Result exceedingLength(@required T failedValue, @required int max),
    @required Result empty(@required T failedValue),
    @required Result multiline(@required T failedValue),
    @required Result invalidNumber(@required T failedValue),
    @required Result numberToLow(@required T failedValue),
    @required Result numberToBig(@required T failedValue),
    @required Result invalidEmail(@required T failedValue),
    @required Result emailMissingDot(@required T failedValue),
    @required Result emailHasSpace(@required T failedValue),
    @required Result invalidPassword(@required T failedValue),
    @required Result invalidPhoneNumber(@required T failedValue),
    @required Result phoneNumberNotStartsWith3(@required T failedValue),
    @required Result notValidOperatorMX(@required T failedValue),
    @required Result invalidName(@required T failedValue),
    @required Result nameTooShort(@required T failedValue),
    @required Result nameTooLong(@required T failedValue),
    @required Result phoneNumberToShort(@required T failedValue),
    @required Result goalMinPassed(@required T failedValue),
    @required Result underMin(@required T failedValue),
    @required Result emailHasSpaceBeginning(@required T failedValue),
    @required Result missingDotAfterExt(@required T failedValue),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(invalidNumber != null);
    assert(numberToLow != null);
    assert(numberToBig != null);
    assert(invalidEmail != null);
    assert(emailMissingDot != null);
    assert(emailHasSpace != null);
    assert(invalidPassword != null);
    assert(invalidPhoneNumber != null);
    assert(phoneNumberNotStartsWith3 != null);
    assert(notValidOperatorMX != null);
    assert(invalidName != null);
    assert(nameTooShort != null);
    assert(nameTooLong != null);
    assert(phoneNumberToShort != null);
    assert(goalMinPassed != null);
    assert(underMin != null);
    assert(emailHasSpaceBeginning != null);
    assert(missingDotAfterExt != null);
    return phoneNumberToShort(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result exceedingLength(@required T failedValue, @required int max),
    Result empty(@required T failedValue),
    Result multiline(@required T failedValue),
    Result invalidNumber(@required T failedValue),
    Result numberToLow(@required T failedValue),
    Result numberToBig(@required T failedValue),
    Result invalidEmail(@required T failedValue),
    Result emailMissingDot(@required T failedValue),
    Result emailHasSpace(@required T failedValue),
    Result invalidPassword(@required T failedValue),
    Result invalidPhoneNumber(@required T failedValue),
    Result phoneNumberNotStartsWith3(@required T failedValue),
    Result notValidOperatorMX(@required T failedValue),
    Result invalidName(@required T failedValue),
    Result nameTooShort(@required T failedValue),
    Result nameTooLong(@required T failedValue),
    Result phoneNumberToShort(@required T failedValue),
    Result goalMinPassed(@required T failedValue),
    Result underMin(@required T failedValue),
    Result emailHasSpaceBeginning(@required T failedValue),
    Result missingDotAfterExt(@required T failedValue),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (phoneNumberToShort != null) {
      return phoneNumberToShort(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result exceedingLength(ExceedingLength<T> value),
    @required Result empty(Empty<T> value),
    @required Result multiline(Multiline<T> value),
    @required Result invalidNumber(InvalidNumber<T> value),
    @required Result numberToLow(NumberToLow<T> value),
    @required Result numberToBig(NumberToBig<T> value),
    @required Result invalidEmail(InvalidEmail<T> value),
    @required Result emailMissingDot(EmailMissingDot<T> value),
    @required Result emailHasSpace(EmailHasSpace<T> value),
    @required Result invalidPassword(InvalidPassword<T> value),
    @required Result invalidPhoneNumber(InvalidPhoneNumber<T> value),
    @required
        Result phoneNumberNotStartsWith3(PhoneNumberNotStartsWith3<T> value),
    @required Result notValidOperatorMX(NotValidOperatorMX<T> value),
    @required Result invalidName(InvalidName<T> value),
    @required Result nameTooShort(NameTooShort<T> value),
    @required Result nameTooLong(NameTooLong<T> value),
    @required Result phoneNumberToShort(PhoneNumberTooShort<T> value),
    @required Result goalMinPassed(GoalMinPassed<T> value),
    @required Result underMin(UnderMin<T> value),
    @required Result emailHasSpaceBeginning(EmailHasSpaceBeginning<T> value),
    @required Result missingDotAfterExt(MissingDotAfterExt<T> value),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(invalidNumber != null);
    assert(numberToLow != null);
    assert(numberToBig != null);
    assert(invalidEmail != null);
    assert(emailMissingDot != null);
    assert(emailHasSpace != null);
    assert(invalidPassword != null);
    assert(invalidPhoneNumber != null);
    assert(phoneNumberNotStartsWith3 != null);
    assert(notValidOperatorMX != null);
    assert(invalidName != null);
    assert(nameTooShort != null);
    assert(nameTooLong != null);
    assert(phoneNumberToShort != null);
    assert(goalMinPassed != null);
    assert(underMin != null);
    assert(emailHasSpaceBeginning != null);
    assert(missingDotAfterExt != null);
    return phoneNumberToShort(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result exceedingLength(ExceedingLength<T> value),
    Result empty(Empty<T> value),
    Result multiline(Multiline<T> value),
    Result invalidNumber(InvalidNumber<T> value),
    Result numberToLow(NumberToLow<T> value),
    Result numberToBig(NumberToBig<T> value),
    Result invalidEmail(InvalidEmail<T> value),
    Result emailMissingDot(EmailMissingDot<T> value),
    Result emailHasSpace(EmailHasSpace<T> value),
    Result invalidPassword(InvalidPassword<T> value),
    Result invalidPhoneNumber(InvalidPhoneNumber<T> value),
    Result phoneNumberNotStartsWith3(PhoneNumberNotStartsWith3<T> value),
    Result notValidOperatorMX(NotValidOperatorMX<T> value),
    Result invalidName(InvalidName<T> value),
    Result nameTooShort(NameTooShort<T> value),
    Result nameTooLong(NameTooLong<T> value),
    Result phoneNumberToShort(PhoneNumberTooShort<T> value),
    Result goalMinPassed(GoalMinPassed<T> value),
    Result underMin(UnderMin<T> value),
    Result emailHasSpaceBeginning(EmailHasSpaceBeginning<T> value),
    Result missingDotAfterExt(MissingDotAfterExt<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (phoneNumberToShort != null) {
      return phoneNumberToShort(this);
    }
    return orElse();
  }
}

abstract class PhoneNumberTooShort<T> implements ValueFailure<T> {
  const factory PhoneNumberTooShort({@required T failedValue}) =
      _$PhoneNumberTooShort<T>;

  @override
  T get failedValue;

  @override
  PhoneNumberTooShort<T> copyWith({T failedValue});
}

class _$GoalMinPassed<T>
    with DiagnosticableTreeMixin
    implements GoalMinPassed<T> {
  const _$GoalMinPassed({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ValueFailure<$T>.goalMinPassed(failedValue: $failedValue)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ValueFailure<$T>.goalMinPassed'))
      ..add(DiagnosticsProperty('failedValue', failedValue));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is GoalMinPassed<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  _$GoalMinPassed<T> copyWith({
    Object failedValue = freezed,
  }) {
    return _$GoalMinPassed<T>(
      failedValue: failedValue == freezed ? this.failedValue : failedValue as T,
    );
  }

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required
        Result exceedingLength(@required T failedValue, @required int max),
    @required Result empty(@required T failedValue),
    @required Result multiline(@required T failedValue),
    @required Result invalidNumber(@required T failedValue),
    @required Result numberToLow(@required T failedValue),
    @required Result numberToBig(@required T failedValue),
    @required Result invalidEmail(@required T failedValue),
    @required Result emailMissingDot(@required T failedValue),
    @required Result emailHasSpace(@required T failedValue),
    @required Result invalidPassword(@required T failedValue),
    @required Result invalidPhoneNumber(@required T failedValue),
    @required Result phoneNumberNotStartsWith3(@required T failedValue),
    @required Result notValidOperatorMX(@required T failedValue),
    @required Result invalidName(@required T failedValue),
    @required Result nameTooShort(@required T failedValue),
    @required Result nameTooLong(@required T failedValue),
    @required Result phoneNumberToShort(@required T failedValue),
    @required Result goalMinPassed(@required T failedValue),
    @required Result underMin(@required T failedValue),
    @required Result emailHasSpaceBeginning(@required T failedValue),
    @required Result missingDotAfterExt(@required T failedValue),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(invalidNumber != null);
    assert(numberToLow != null);
    assert(numberToBig != null);
    assert(invalidEmail != null);
    assert(emailMissingDot != null);
    assert(emailHasSpace != null);
    assert(invalidPassword != null);
    assert(invalidPhoneNumber != null);
    assert(phoneNumberNotStartsWith3 != null);
    assert(notValidOperatorMX != null);
    assert(invalidName != null);
    assert(nameTooShort != null);
    assert(nameTooLong != null);
    assert(phoneNumberToShort != null);
    assert(goalMinPassed != null);
    assert(underMin != null);
    assert(emailHasSpaceBeginning != null);
    assert(missingDotAfterExt != null);
    return goalMinPassed(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result exceedingLength(@required T failedValue, @required int max),
    Result empty(@required T failedValue),
    Result multiline(@required T failedValue),
    Result invalidNumber(@required T failedValue),
    Result numberToLow(@required T failedValue),
    Result numberToBig(@required T failedValue),
    Result invalidEmail(@required T failedValue),
    Result emailMissingDot(@required T failedValue),
    Result emailHasSpace(@required T failedValue),
    Result invalidPassword(@required T failedValue),
    Result invalidPhoneNumber(@required T failedValue),
    Result phoneNumberNotStartsWith3(@required T failedValue),
    Result notValidOperatorMX(@required T failedValue),
    Result invalidName(@required T failedValue),
    Result nameTooShort(@required T failedValue),
    Result nameTooLong(@required T failedValue),
    Result phoneNumberToShort(@required T failedValue),
    Result goalMinPassed(@required T failedValue),
    Result underMin(@required T failedValue),
    Result emailHasSpaceBeginning(@required T failedValue),
    Result missingDotAfterExt(@required T failedValue),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (goalMinPassed != null) {
      return goalMinPassed(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result exceedingLength(ExceedingLength<T> value),
    @required Result empty(Empty<T> value),
    @required Result multiline(Multiline<T> value),
    @required Result invalidNumber(InvalidNumber<T> value),
    @required Result numberToLow(NumberToLow<T> value),
    @required Result numberToBig(NumberToBig<T> value),
    @required Result invalidEmail(InvalidEmail<T> value),
    @required Result emailMissingDot(EmailMissingDot<T> value),
    @required Result emailHasSpace(EmailHasSpace<T> value),
    @required Result invalidPassword(InvalidPassword<T> value),
    @required Result invalidPhoneNumber(InvalidPhoneNumber<T> value),
    @required
        Result phoneNumberNotStartsWith3(PhoneNumberNotStartsWith3<T> value),
    @required Result notValidOperatorMX(NotValidOperatorMX<T> value),
    @required Result invalidName(InvalidName<T> value),
    @required Result nameTooShort(NameTooShort<T> value),
    @required Result nameTooLong(NameTooLong<T> value),
    @required Result phoneNumberToShort(PhoneNumberTooShort<T> value),
    @required Result goalMinPassed(GoalMinPassed<T> value),
    @required Result underMin(UnderMin<T> value),
    @required Result emailHasSpaceBeginning(EmailHasSpaceBeginning<T> value),
    @required Result missingDotAfterExt(MissingDotAfterExt<T> value),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(invalidNumber != null);
    assert(numberToLow != null);
    assert(numberToBig != null);
    assert(invalidEmail != null);
    assert(emailMissingDot != null);
    assert(emailHasSpace != null);
    assert(invalidPassword != null);
    assert(invalidPhoneNumber != null);
    assert(phoneNumberNotStartsWith3 != null);
    assert(notValidOperatorMX != null);
    assert(invalidName != null);
    assert(nameTooShort != null);
    assert(nameTooLong != null);
    assert(phoneNumberToShort != null);
    assert(goalMinPassed != null);
    assert(underMin != null);
    assert(emailHasSpaceBeginning != null);
    assert(missingDotAfterExt != null);
    return goalMinPassed(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result exceedingLength(ExceedingLength<T> value),
    Result empty(Empty<T> value),
    Result multiline(Multiline<T> value),
    Result invalidNumber(InvalidNumber<T> value),
    Result numberToLow(NumberToLow<T> value),
    Result numberToBig(NumberToBig<T> value),
    Result invalidEmail(InvalidEmail<T> value),
    Result emailMissingDot(EmailMissingDot<T> value),
    Result emailHasSpace(EmailHasSpace<T> value),
    Result invalidPassword(InvalidPassword<T> value),
    Result invalidPhoneNumber(InvalidPhoneNumber<T> value),
    Result phoneNumberNotStartsWith3(PhoneNumberNotStartsWith3<T> value),
    Result notValidOperatorMX(NotValidOperatorMX<T> value),
    Result invalidName(InvalidName<T> value),
    Result nameTooShort(NameTooShort<T> value),
    Result nameTooLong(NameTooLong<T> value),
    Result phoneNumberToShort(PhoneNumberTooShort<T> value),
    Result goalMinPassed(GoalMinPassed<T> value),
    Result underMin(UnderMin<T> value),
    Result emailHasSpaceBeginning(EmailHasSpaceBeginning<T> value),
    Result missingDotAfterExt(MissingDotAfterExt<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (goalMinPassed != null) {
      return goalMinPassed(this);
    }
    return orElse();
  }
}

abstract class GoalMinPassed<T> implements ValueFailure<T> {
  const factory GoalMinPassed({@required T failedValue}) = _$GoalMinPassed<T>;

  @override
  T get failedValue;

  @override
  GoalMinPassed<T> copyWith({T failedValue});
}

class _$UnderMin<T> with DiagnosticableTreeMixin implements UnderMin<T> {
  const _$UnderMin({@required this.failedValue}) : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ValueFailure<$T>.underMin(failedValue: $failedValue)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ValueFailure<$T>.underMin'))
      ..add(DiagnosticsProperty('failedValue', failedValue));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is UnderMin<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  _$UnderMin<T> copyWith({
    Object failedValue = freezed,
  }) {
    return _$UnderMin<T>(
      failedValue: failedValue == freezed ? this.failedValue : failedValue as T,
    );
  }

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required
        Result exceedingLength(@required T failedValue, @required int max),
    @required Result empty(@required T failedValue),
    @required Result multiline(@required T failedValue),
    @required Result invalidNumber(@required T failedValue),
    @required Result numberToLow(@required T failedValue),
    @required Result numberToBig(@required T failedValue),
    @required Result invalidEmail(@required T failedValue),
    @required Result emailMissingDot(@required T failedValue),
    @required Result emailHasSpace(@required T failedValue),
    @required Result invalidPassword(@required T failedValue),
    @required Result invalidPhoneNumber(@required T failedValue),
    @required Result phoneNumberNotStartsWith3(@required T failedValue),
    @required Result notValidOperatorMX(@required T failedValue),
    @required Result invalidName(@required T failedValue),
    @required Result nameTooShort(@required T failedValue),
    @required Result nameTooLong(@required T failedValue),
    @required Result phoneNumberToShort(@required T failedValue),
    @required Result goalMinPassed(@required T failedValue),
    @required Result underMin(@required T failedValue),
    @required Result emailHasSpaceBeginning(@required T failedValue),
    @required Result missingDotAfterExt(@required T failedValue),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(invalidNumber != null);
    assert(numberToLow != null);
    assert(numberToBig != null);
    assert(invalidEmail != null);
    assert(emailMissingDot != null);
    assert(emailHasSpace != null);
    assert(invalidPassword != null);
    assert(invalidPhoneNumber != null);
    assert(phoneNumberNotStartsWith3 != null);
    assert(notValidOperatorMX != null);
    assert(invalidName != null);
    assert(nameTooShort != null);
    assert(nameTooLong != null);
    assert(phoneNumberToShort != null);
    assert(goalMinPassed != null);
    assert(underMin != null);
    assert(emailHasSpaceBeginning != null);
    assert(missingDotAfterExt != null);
    return underMin(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result exceedingLength(@required T failedValue, @required int max),
    Result empty(@required T failedValue),
    Result multiline(@required T failedValue),
    Result invalidNumber(@required T failedValue),
    Result numberToLow(@required T failedValue),
    Result numberToBig(@required T failedValue),
    Result invalidEmail(@required T failedValue),
    Result emailMissingDot(@required T failedValue),
    Result emailHasSpace(@required T failedValue),
    Result invalidPassword(@required T failedValue),
    Result invalidPhoneNumber(@required T failedValue),
    Result phoneNumberNotStartsWith3(@required T failedValue),
    Result notValidOperatorMX(@required T failedValue),
    Result invalidName(@required T failedValue),
    Result nameTooShort(@required T failedValue),
    Result nameTooLong(@required T failedValue),
    Result phoneNumberToShort(@required T failedValue),
    Result goalMinPassed(@required T failedValue),
    Result underMin(@required T failedValue),
    Result emailHasSpaceBeginning(@required T failedValue),
    Result missingDotAfterExt(@required T failedValue),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (underMin != null) {
      return underMin(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result exceedingLength(ExceedingLength<T> value),
    @required Result empty(Empty<T> value),
    @required Result multiline(Multiline<T> value),
    @required Result invalidNumber(InvalidNumber<T> value),
    @required Result numberToLow(NumberToLow<T> value),
    @required Result numberToBig(NumberToBig<T> value),
    @required Result invalidEmail(InvalidEmail<T> value),
    @required Result emailMissingDot(EmailMissingDot<T> value),
    @required Result emailHasSpace(EmailHasSpace<T> value),
    @required Result invalidPassword(InvalidPassword<T> value),
    @required Result invalidPhoneNumber(InvalidPhoneNumber<T> value),
    @required
        Result phoneNumberNotStartsWith3(PhoneNumberNotStartsWith3<T> value),
    @required Result notValidOperatorMX(NotValidOperatorMX<T> value),
    @required Result invalidName(InvalidName<T> value),
    @required Result nameTooShort(NameTooShort<T> value),
    @required Result nameTooLong(NameTooLong<T> value),
    @required Result phoneNumberToShort(PhoneNumberTooShort<T> value),
    @required Result goalMinPassed(GoalMinPassed<T> value),
    @required Result underMin(UnderMin<T> value),
    @required Result emailHasSpaceBeginning(EmailHasSpaceBeginning<T> value),
    @required Result missingDotAfterExt(MissingDotAfterExt<T> value),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(invalidNumber != null);
    assert(numberToLow != null);
    assert(numberToBig != null);
    assert(invalidEmail != null);
    assert(emailMissingDot != null);
    assert(emailHasSpace != null);
    assert(invalidPassword != null);
    assert(invalidPhoneNumber != null);
    assert(phoneNumberNotStartsWith3 != null);
    assert(notValidOperatorMX != null);
    assert(invalidName != null);
    assert(nameTooShort != null);
    assert(nameTooLong != null);
    assert(phoneNumberToShort != null);
    assert(goalMinPassed != null);
    assert(underMin != null);
    assert(emailHasSpaceBeginning != null);
    assert(missingDotAfterExt != null);
    return underMin(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result exceedingLength(ExceedingLength<T> value),
    Result empty(Empty<T> value),
    Result multiline(Multiline<T> value),
    Result invalidNumber(InvalidNumber<T> value),
    Result numberToLow(NumberToLow<T> value),
    Result numberToBig(NumberToBig<T> value),
    Result invalidEmail(InvalidEmail<T> value),
    Result emailMissingDot(EmailMissingDot<T> value),
    Result emailHasSpace(EmailHasSpace<T> value),
    Result invalidPassword(InvalidPassword<T> value),
    Result invalidPhoneNumber(InvalidPhoneNumber<T> value),
    Result phoneNumberNotStartsWith3(PhoneNumberNotStartsWith3<T> value),
    Result notValidOperatorMX(NotValidOperatorMX<T> value),
    Result invalidName(InvalidName<T> value),
    Result nameTooShort(NameTooShort<T> value),
    Result nameTooLong(NameTooLong<T> value),
    Result phoneNumberToShort(PhoneNumberTooShort<T> value),
    Result goalMinPassed(GoalMinPassed<T> value),
    Result underMin(UnderMin<T> value),
    Result emailHasSpaceBeginning(EmailHasSpaceBeginning<T> value),
    Result missingDotAfterExt(MissingDotAfterExt<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (underMin != null) {
      return underMin(this);
    }
    return orElse();
  }
}

abstract class UnderMin<T> implements ValueFailure<T> {
  const factory UnderMin({@required T failedValue}) = _$UnderMin<T>;

  @override
  T get failedValue;

  @override
  UnderMin<T> copyWith({T failedValue});
}

class _$EmailHasSpaceBeginning<T>
    with DiagnosticableTreeMixin
    implements EmailHasSpaceBeginning<T> {
  const _$EmailHasSpaceBeginning({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ValueFailure<$T>.emailHasSpaceBeginning(failedValue: $failedValue)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty(
          'type', 'ValueFailure<$T>.emailHasSpaceBeginning'))
      ..add(DiagnosticsProperty('failedValue', failedValue));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is EmailHasSpaceBeginning<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  _$EmailHasSpaceBeginning<T> copyWith({
    Object failedValue = freezed,
  }) {
    return _$EmailHasSpaceBeginning<T>(
      failedValue: failedValue == freezed ? this.failedValue : failedValue as T,
    );
  }

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required
        Result exceedingLength(@required T failedValue, @required int max),
    @required Result empty(@required T failedValue),
    @required Result multiline(@required T failedValue),
    @required Result invalidNumber(@required T failedValue),
    @required Result numberToLow(@required T failedValue),
    @required Result numberToBig(@required T failedValue),
    @required Result invalidEmail(@required T failedValue),
    @required Result emailMissingDot(@required T failedValue),
    @required Result emailHasSpace(@required T failedValue),
    @required Result invalidPassword(@required T failedValue),
    @required Result invalidPhoneNumber(@required T failedValue),
    @required Result phoneNumberNotStartsWith3(@required T failedValue),
    @required Result notValidOperatorMX(@required T failedValue),
    @required Result invalidName(@required T failedValue),
    @required Result nameTooShort(@required T failedValue),
    @required Result nameTooLong(@required T failedValue),
    @required Result phoneNumberToShort(@required T failedValue),
    @required Result goalMinPassed(@required T failedValue),
    @required Result underMin(@required T failedValue),
    @required Result emailHasSpaceBeginning(@required T failedValue),
    @required Result missingDotAfterExt(@required T failedValue),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(invalidNumber != null);
    assert(numberToLow != null);
    assert(numberToBig != null);
    assert(invalidEmail != null);
    assert(emailMissingDot != null);
    assert(emailHasSpace != null);
    assert(invalidPassword != null);
    assert(invalidPhoneNumber != null);
    assert(phoneNumberNotStartsWith3 != null);
    assert(notValidOperatorMX != null);
    assert(invalidName != null);
    assert(nameTooShort != null);
    assert(nameTooLong != null);
    assert(phoneNumberToShort != null);
    assert(goalMinPassed != null);
    assert(underMin != null);
    assert(emailHasSpaceBeginning != null);
    assert(missingDotAfterExt != null);
    return emailHasSpaceBeginning(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result exceedingLength(@required T failedValue, @required int max),
    Result empty(@required T failedValue),
    Result multiline(@required T failedValue),
    Result invalidNumber(@required T failedValue),
    Result numberToLow(@required T failedValue),
    Result numberToBig(@required T failedValue),
    Result invalidEmail(@required T failedValue),
    Result emailMissingDot(@required T failedValue),
    Result emailHasSpace(@required T failedValue),
    Result invalidPassword(@required T failedValue),
    Result invalidPhoneNumber(@required T failedValue),
    Result phoneNumberNotStartsWith3(@required T failedValue),
    Result notValidOperatorMX(@required T failedValue),
    Result invalidName(@required T failedValue),
    Result nameTooShort(@required T failedValue),
    Result nameTooLong(@required T failedValue),
    Result phoneNumberToShort(@required T failedValue),
    Result goalMinPassed(@required T failedValue),
    Result underMin(@required T failedValue),
    Result emailHasSpaceBeginning(@required T failedValue),
    Result missingDotAfterExt(@required T failedValue),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (emailHasSpaceBeginning != null) {
      return emailHasSpaceBeginning(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result exceedingLength(ExceedingLength<T> value),
    @required Result empty(Empty<T> value),
    @required Result multiline(Multiline<T> value),
    @required Result invalidNumber(InvalidNumber<T> value),
    @required Result numberToLow(NumberToLow<T> value),
    @required Result numberToBig(NumberToBig<T> value),
    @required Result invalidEmail(InvalidEmail<T> value),
    @required Result emailMissingDot(EmailMissingDot<T> value),
    @required Result emailHasSpace(EmailHasSpace<T> value),
    @required Result invalidPassword(InvalidPassword<T> value),
    @required Result invalidPhoneNumber(InvalidPhoneNumber<T> value),
    @required
        Result phoneNumberNotStartsWith3(PhoneNumberNotStartsWith3<T> value),
    @required Result notValidOperatorMX(NotValidOperatorMX<T> value),
    @required Result invalidName(InvalidName<T> value),
    @required Result nameTooShort(NameTooShort<T> value),
    @required Result nameTooLong(NameTooLong<T> value),
    @required Result phoneNumberToShort(PhoneNumberTooShort<T> value),
    @required Result goalMinPassed(GoalMinPassed<T> value),
    @required Result underMin(UnderMin<T> value),
    @required Result emailHasSpaceBeginning(EmailHasSpaceBeginning<T> value),
    @required Result missingDotAfterExt(MissingDotAfterExt<T> value),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(invalidNumber != null);
    assert(numberToLow != null);
    assert(numberToBig != null);
    assert(invalidEmail != null);
    assert(emailMissingDot != null);
    assert(emailHasSpace != null);
    assert(invalidPassword != null);
    assert(invalidPhoneNumber != null);
    assert(phoneNumberNotStartsWith3 != null);
    assert(notValidOperatorMX != null);
    assert(invalidName != null);
    assert(nameTooShort != null);
    assert(nameTooLong != null);
    assert(phoneNumberToShort != null);
    assert(goalMinPassed != null);
    assert(underMin != null);
    assert(emailHasSpaceBeginning != null);
    assert(missingDotAfterExt != null);
    return emailHasSpaceBeginning(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result exceedingLength(ExceedingLength<T> value),
    Result empty(Empty<T> value),
    Result multiline(Multiline<T> value),
    Result invalidNumber(InvalidNumber<T> value),
    Result numberToLow(NumberToLow<T> value),
    Result numberToBig(NumberToBig<T> value),
    Result invalidEmail(InvalidEmail<T> value),
    Result emailMissingDot(EmailMissingDot<T> value),
    Result emailHasSpace(EmailHasSpace<T> value),
    Result invalidPassword(InvalidPassword<T> value),
    Result invalidPhoneNumber(InvalidPhoneNumber<T> value),
    Result phoneNumberNotStartsWith3(PhoneNumberNotStartsWith3<T> value),
    Result notValidOperatorMX(NotValidOperatorMX<T> value),
    Result invalidName(InvalidName<T> value),
    Result nameTooShort(NameTooShort<T> value),
    Result nameTooLong(NameTooLong<T> value),
    Result phoneNumberToShort(PhoneNumberTooShort<T> value),
    Result goalMinPassed(GoalMinPassed<T> value),
    Result underMin(UnderMin<T> value),
    Result emailHasSpaceBeginning(EmailHasSpaceBeginning<T> value),
    Result missingDotAfterExt(MissingDotAfterExt<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (emailHasSpaceBeginning != null) {
      return emailHasSpaceBeginning(this);
    }
    return orElse();
  }
}

abstract class EmailHasSpaceBeginning<T> implements ValueFailure<T> {
  const factory EmailHasSpaceBeginning({@required T failedValue}) =
      _$EmailHasSpaceBeginning<T>;

  @override
  T get failedValue;

  @override
  EmailHasSpaceBeginning<T> copyWith({T failedValue});
}

class _$MissingDotAfterExt<T>
    with DiagnosticableTreeMixin
    implements MissingDotAfterExt<T> {
  const _$MissingDotAfterExt({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ValueFailure<$T>.missingDotAfterExt(failedValue: $failedValue)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ValueFailure<$T>.missingDotAfterExt'))
      ..add(DiagnosticsProperty('failedValue', failedValue));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is MissingDotAfterExt<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  _$MissingDotAfterExt<T> copyWith({
    Object failedValue = freezed,
  }) {
    return _$MissingDotAfterExt<T>(
      failedValue: failedValue == freezed ? this.failedValue : failedValue as T,
    );
  }

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required
        Result exceedingLength(@required T failedValue, @required int max),
    @required Result empty(@required T failedValue),
    @required Result multiline(@required T failedValue),
    @required Result invalidNumber(@required T failedValue),
    @required Result numberToLow(@required T failedValue),
    @required Result numberToBig(@required T failedValue),
    @required Result invalidEmail(@required T failedValue),
    @required Result emailMissingDot(@required T failedValue),
    @required Result emailHasSpace(@required T failedValue),
    @required Result invalidPassword(@required T failedValue),
    @required Result invalidPhoneNumber(@required T failedValue),
    @required Result phoneNumberNotStartsWith3(@required T failedValue),
    @required Result notValidOperatorMX(@required T failedValue),
    @required Result invalidName(@required T failedValue),
    @required Result nameTooShort(@required T failedValue),
    @required Result nameTooLong(@required T failedValue),
    @required Result phoneNumberToShort(@required T failedValue),
    @required Result goalMinPassed(@required T failedValue),
    @required Result underMin(@required T failedValue),
    @required Result emailHasSpaceBeginning(@required T failedValue),
    @required Result missingDotAfterExt(@required T failedValue),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(invalidNumber != null);
    assert(numberToLow != null);
    assert(numberToBig != null);
    assert(invalidEmail != null);
    assert(emailMissingDot != null);
    assert(emailHasSpace != null);
    assert(invalidPassword != null);
    assert(invalidPhoneNumber != null);
    assert(phoneNumberNotStartsWith3 != null);
    assert(notValidOperatorMX != null);
    assert(invalidName != null);
    assert(nameTooShort != null);
    assert(nameTooLong != null);
    assert(phoneNumberToShort != null);
    assert(goalMinPassed != null);
    assert(underMin != null);
    assert(emailHasSpaceBeginning != null);
    assert(missingDotAfterExt != null);
    return missingDotAfterExt(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result exceedingLength(@required T failedValue, @required int max),
    Result empty(@required T failedValue),
    Result multiline(@required T failedValue),
    Result invalidNumber(@required T failedValue),
    Result numberToLow(@required T failedValue),
    Result numberToBig(@required T failedValue),
    Result invalidEmail(@required T failedValue),
    Result emailMissingDot(@required T failedValue),
    Result emailHasSpace(@required T failedValue),
    Result invalidPassword(@required T failedValue),
    Result invalidPhoneNumber(@required T failedValue),
    Result phoneNumberNotStartsWith3(@required T failedValue),
    Result notValidOperatorMX(@required T failedValue),
    Result invalidName(@required T failedValue),
    Result nameTooShort(@required T failedValue),
    Result nameTooLong(@required T failedValue),
    Result phoneNumberToShort(@required T failedValue),
    Result goalMinPassed(@required T failedValue),
    Result underMin(@required T failedValue),
    Result emailHasSpaceBeginning(@required T failedValue),
    Result missingDotAfterExt(@required T failedValue),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (missingDotAfterExt != null) {
      return missingDotAfterExt(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result exceedingLength(ExceedingLength<T> value),
    @required Result empty(Empty<T> value),
    @required Result multiline(Multiline<T> value),
    @required Result invalidNumber(InvalidNumber<T> value),
    @required Result numberToLow(NumberToLow<T> value),
    @required Result numberToBig(NumberToBig<T> value),
    @required Result invalidEmail(InvalidEmail<T> value),
    @required Result emailMissingDot(EmailMissingDot<T> value),
    @required Result emailHasSpace(EmailHasSpace<T> value),
    @required Result invalidPassword(InvalidPassword<T> value),
    @required Result invalidPhoneNumber(InvalidPhoneNumber<T> value),
    @required
        Result phoneNumberNotStartsWith3(PhoneNumberNotStartsWith3<T> value),
    @required Result notValidOperatorMX(NotValidOperatorMX<T> value),
    @required Result invalidName(InvalidName<T> value),
    @required Result nameTooShort(NameTooShort<T> value),
    @required Result nameTooLong(NameTooLong<T> value),
    @required Result phoneNumberToShort(PhoneNumberTooShort<T> value),
    @required Result goalMinPassed(GoalMinPassed<T> value),
    @required Result underMin(UnderMin<T> value),
    @required Result emailHasSpaceBeginning(EmailHasSpaceBeginning<T> value),
    @required Result missingDotAfterExt(MissingDotAfterExt<T> value),
  }) {
    assert(exceedingLength != null);
    assert(empty != null);
    assert(multiline != null);
    assert(invalidNumber != null);
    assert(numberToLow != null);
    assert(numberToBig != null);
    assert(invalidEmail != null);
    assert(emailMissingDot != null);
    assert(emailHasSpace != null);
    assert(invalidPassword != null);
    assert(invalidPhoneNumber != null);
    assert(phoneNumberNotStartsWith3 != null);
    assert(notValidOperatorMX != null);
    assert(invalidName != null);
    assert(nameTooShort != null);
    assert(nameTooLong != null);
    assert(phoneNumberToShort != null);
    assert(goalMinPassed != null);
    assert(underMin != null);
    assert(emailHasSpaceBeginning != null);
    assert(missingDotAfterExt != null);
    return missingDotAfterExt(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result exceedingLength(ExceedingLength<T> value),
    Result empty(Empty<T> value),
    Result multiline(Multiline<T> value),
    Result invalidNumber(InvalidNumber<T> value),
    Result numberToLow(NumberToLow<T> value),
    Result numberToBig(NumberToBig<T> value),
    Result invalidEmail(InvalidEmail<T> value),
    Result emailMissingDot(EmailMissingDot<T> value),
    Result emailHasSpace(EmailHasSpace<T> value),
    Result invalidPassword(InvalidPassword<T> value),
    Result invalidPhoneNumber(InvalidPhoneNumber<T> value),
    Result phoneNumberNotStartsWith3(PhoneNumberNotStartsWith3<T> value),
    Result notValidOperatorMX(NotValidOperatorMX<T> value),
    Result invalidName(InvalidName<T> value),
    Result nameTooShort(NameTooShort<T> value),
    Result nameTooLong(NameTooLong<T> value),
    Result phoneNumberToShort(PhoneNumberTooShort<T> value),
    Result goalMinPassed(GoalMinPassed<T> value),
    Result underMin(UnderMin<T> value),
    Result emailHasSpaceBeginning(EmailHasSpaceBeginning<T> value),
    Result missingDotAfterExt(MissingDotAfterExt<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (missingDotAfterExt != null) {
      return missingDotAfterExt(this);
    }
    return orElse();
  }
}

abstract class MissingDotAfterExt<T> implements ValueFailure<T> {
  const factory MissingDotAfterExt({@required T failedValue}) =
      _$MissingDotAfterExt<T>;

  @override
  T get failedValue;

  @override
  MissingDotAfterExt<T> copyWith({T failedValue});
}
