// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named

part of 'investing_dom_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

mixin _$InvestingDomEvent {
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result inicial(),
    @required Result getBanksList(),
    @required Result updateAccountNumber(String accountNumber),
    @required Result updateBank(String newBank),
    @required Result updateAccountType(String newAccountType),
    @required Result createAccount(bool isInvestment),
    @required Result getBankAccounts(),
    @required Result chooseAccount(BankInfo bank),
  });

  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result inicial(),
    Result getBanksList(),
    Result updateAccountNumber(String accountNumber),
    Result updateBank(String newBank),
    Result updateAccountType(String newAccountType),
    Result createAccount(bool isInvestment),
    Result getBankAccounts(),
    Result chooseAccount(BankInfo bank),
    @required Result orElse(),
  });

  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result inicial(_initial value),
    @required Result getBanksList(_getBanksList value),
    @required Result updateAccountNumber(_updateAccountNumber value),
    @required Result updateBank(_updateBank value),
    @required Result updateAccountType(_updateAccountType value),
    @required Result createAccount(_createAccount value),
    @required Result getBankAccounts(_getBankAccounts value),
    @required Result chooseAccount(_chooseAccount value),
  });

  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result inicial(_initial value),
    Result getBanksList(_getBanksList value),
    Result updateAccountNumber(_updateAccountNumber value),
    Result updateBank(_updateBank value),
    Result updateAccountType(_updateAccountType value),
    Result createAccount(_createAccount value),
    Result getBankAccounts(_getBankAccounts value),
    Result chooseAccount(_chooseAccount value),
    @required Result orElse(),
  });
}

class _$InvestingDomEventTearOff {
  const _$InvestingDomEventTearOff();

  _initial inicial() {
    return const _initial();
  }

  _getBanksList getBanksList() {
    return const _getBanksList();
  }

  _updateAccountNumber updateAccountNumber(String accountNumber) {
    return _updateAccountNumber(
      accountNumber,
    );
  }

  _updateBank updateBank(String newBank) {
    return _updateBank(
      newBank,
    );
  }

  _updateAccountType updateAccountType(String newAccountType) {
    return _updateAccountType(
      newAccountType,
    );
  }

  _createAccount createAccount(bool isInvestment) {
    return _createAccount(
      isInvestment,
    );
  }

  _getBankAccounts getBankAccounts() {
    return const _getBankAccounts();
  }

  _chooseAccount chooseAccount(BankInfo bank) {
    return _chooseAccount(
      bank,
    );
  }
}

const $InvestingDomEvent = _$InvestingDomEventTearOff();

class _$_initial implements _initial {
  const _$_initial();

  @override
  String toString() {
    return 'InvestingDomEvent.inicial()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _initial);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result inicial(),
    @required Result getBanksList(),
    @required Result updateAccountNumber(String accountNumber),
    @required Result updateBank(String newBank),
    @required Result updateAccountType(String newAccountType),
    @required Result createAccount(bool isInvestment),
    @required Result getBankAccounts(),
    @required Result chooseAccount(BankInfo bank),
  }) {
    assert(inicial != null);
    assert(getBanksList != null);
    assert(updateAccountNumber != null);
    assert(updateBank != null);
    assert(updateAccountType != null);
    assert(createAccount != null);
    assert(getBankAccounts != null);
    assert(chooseAccount != null);
    return inicial();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result inicial(),
    Result getBanksList(),
    Result updateAccountNumber(String accountNumber),
    Result updateBank(String newBank),
    Result updateAccountType(String newAccountType),
    Result createAccount(bool isInvestment),
    Result getBankAccounts(),
    Result chooseAccount(BankInfo bank),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (inicial != null) {
      return inicial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result inicial(_initial value),
    @required Result getBanksList(_getBanksList value),
    @required Result updateAccountNumber(_updateAccountNumber value),
    @required Result updateBank(_updateBank value),
    @required Result updateAccountType(_updateAccountType value),
    @required Result createAccount(_createAccount value),
    @required Result getBankAccounts(_getBankAccounts value),
    @required Result chooseAccount(_chooseAccount value),
  }) {
    assert(inicial != null);
    assert(getBanksList != null);
    assert(updateAccountNumber != null);
    assert(updateBank != null);
    assert(updateAccountType != null);
    assert(createAccount != null);
    assert(getBankAccounts != null);
    assert(chooseAccount != null);
    return inicial(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result inicial(_initial value),
    Result getBanksList(_getBanksList value),
    Result updateAccountNumber(_updateAccountNumber value),
    Result updateBank(_updateBank value),
    Result updateAccountType(_updateAccountType value),
    Result createAccount(_createAccount value),
    Result getBankAccounts(_getBankAccounts value),
    Result chooseAccount(_chooseAccount value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (inicial != null) {
      return inicial(this);
    }
    return orElse();
  }
}

abstract class _initial implements InvestingDomEvent {
  const factory _initial() = _$_initial;
}

class _$_getBanksList implements _getBanksList {
  const _$_getBanksList();

  @override
  String toString() {
    return 'InvestingDomEvent.getBanksList()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _getBanksList);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result inicial(),
    @required Result getBanksList(),
    @required Result updateAccountNumber(String accountNumber),
    @required Result updateBank(String newBank),
    @required Result updateAccountType(String newAccountType),
    @required Result createAccount(bool isInvestment),
    @required Result getBankAccounts(),
    @required Result chooseAccount(BankInfo bank),
  }) {
    assert(inicial != null);
    assert(getBanksList != null);
    assert(updateAccountNumber != null);
    assert(updateBank != null);
    assert(updateAccountType != null);
    assert(createAccount != null);
    assert(getBankAccounts != null);
    assert(chooseAccount != null);
    return getBanksList();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result inicial(),
    Result getBanksList(),
    Result updateAccountNumber(String accountNumber),
    Result updateBank(String newBank),
    Result updateAccountType(String newAccountType),
    Result createAccount(bool isInvestment),
    Result getBankAccounts(),
    Result chooseAccount(BankInfo bank),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (getBanksList != null) {
      return getBanksList();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result inicial(_initial value),
    @required Result getBanksList(_getBanksList value),
    @required Result updateAccountNumber(_updateAccountNumber value),
    @required Result updateBank(_updateBank value),
    @required Result updateAccountType(_updateAccountType value),
    @required Result createAccount(_createAccount value),
    @required Result getBankAccounts(_getBankAccounts value),
    @required Result chooseAccount(_chooseAccount value),
  }) {
    assert(inicial != null);
    assert(getBanksList != null);
    assert(updateAccountNumber != null);
    assert(updateBank != null);
    assert(updateAccountType != null);
    assert(createAccount != null);
    assert(getBankAccounts != null);
    assert(chooseAccount != null);
    return getBanksList(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result inicial(_initial value),
    Result getBanksList(_getBanksList value),
    Result updateAccountNumber(_updateAccountNumber value),
    Result updateBank(_updateBank value),
    Result updateAccountType(_updateAccountType value),
    Result createAccount(_createAccount value),
    Result getBankAccounts(_getBankAccounts value),
    Result chooseAccount(_chooseAccount value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (getBanksList != null) {
      return getBanksList(this);
    }
    return orElse();
  }
}

abstract class _getBanksList implements InvestingDomEvent {
  const factory _getBanksList() = _$_getBanksList;
}

class _$_updateAccountNumber implements _updateAccountNumber {
  const _$_updateAccountNumber(this.accountNumber)
      : assert(accountNumber != null);

  @override
  final String accountNumber;

  @override
  String toString() {
    return 'InvestingDomEvent.updateAccountNumber(accountNumber: $accountNumber)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _updateAccountNumber &&
            (identical(other.accountNumber, accountNumber) ||
                const DeepCollectionEquality()
                    .equals(other.accountNumber, accountNumber)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(accountNumber);

  @override
  _$_updateAccountNumber copyWith({
    Object accountNumber = freezed,
  }) {
    return _$_updateAccountNumber(
      accountNumber == freezed ? this.accountNumber : accountNumber as String,
    );
  }

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result inicial(),
    @required Result getBanksList(),
    @required Result updateAccountNumber(String accountNumber),
    @required Result updateBank(String newBank),
    @required Result updateAccountType(String newAccountType),
    @required Result createAccount(bool isInvestment),
    @required Result getBankAccounts(),
    @required Result chooseAccount(BankInfo bank),
  }) {
    assert(inicial != null);
    assert(getBanksList != null);
    assert(updateAccountNumber != null);
    assert(updateBank != null);
    assert(updateAccountType != null);
    assert(createAccount != null);
    assert(getBankAccounts != null);
    assert(chooseAccount != null);
    return updateAccountNumber(accountNumber);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result inicial(),
    Result getBanksList(),
    Result updateAccountNumber(String accountNumber),
    Result updateBank(String newBank),
    Result updateAccountType(String newAccountType),
    Result createAccount(bool isInvestment),
    Result getBankAccounts(),
    Result chooseAccount(BankInfo bank),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (updateAccountNumber != null) {
      return updateAccountNumber(accountNumber);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result inicial(_initial value),
    @required Result getBanksList(_getBanksList value),
    @required Result updateAccountNumber(_updateAccountNumber value),
    @required Result updateBank(_updateBank value),
    @required Result updateAccountType(_updateAccountType value),
    @required Result createAccount(_createAccount value),
    @required Result getBankAccounts(_getBankAccounts value),
    @required Result chooseAccount(_chooseAccount value),
  }) {
    assert(inicial != null);
    assert(getBanksList != null);
    assert(updateAccountNumber != null);
    assert(updateBank != null);
    assert(updateAccountType != null);
    assert(createAccount != null);
    assert(getBankAccounts != null);
    assert(chooseAccount != null);
    return updateAccountNumber(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result inicial(_initial value),
    Result getBanksList(_getBanksList value),
    Result updateAccountNumber(_updateAccountNumber value),
    Result updateBank(_updateBank value),
    Result updateAccountType(_updateAccountType value),
    Result createAccount(_createAccount value),
    Result getBankAccounts(_getBankAccounts value),
    Result chooseAccount(_chooseAccount value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (updateAccountNumber != null) {
      return updateAccountNumber(this);
    }
    return orElse();
  }
}

abstract class _updateAccountNumber implements InvestingDomEvent {
  const factory _updateAccountNumber(String accountNumber) =
      _$_updateAccountNumber;

  String get accountNumber;

  _updateAccountNumber copyWith({String accountNumber});
}

class _$_updateBank implements _updateBank {
  const _$_updateBank(this.newBank) : assert(newBank != null);

  @override
  final String newBank;

  @override
  String toString() {
    return 'InvestingDomEvent.updateBank(newBank: $newBank)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _updateBank &&
            (identical(other.newBank, newBank) ||
                const DeepCollectionEquality().equals(other.newBank, newBank)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(newBank);

  @override
  _$_updateBank copyWith({
    Object newBank = freezed,
  }) {
    return _$_updateBank(
      newBank == freezed ? this.newBank : newBank as String,
    );
  }

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result inicial(),
    @required Result getBanksList(),
    @required Result updateAccountNumber(String accountNumber),
    @required Result updateBank(String newBank),
    @required Result updateAccountType(String newAccountType),
    @required Result createAccount(bool isInvestment),
    @required Result getBankAccounts(),
    @required Result chooseAccount(BankInfo bank),
  }) {
    assert(inicial != null);
    assert(getBanksList != null);
    assert(updateAccountNumber != null);
    assert(updateBank != null);
    assert(updateAccountType != null);
    assert(createAccount != null);
    assert(getBankAccounts != null);
    assert(chooseAccount != null);
    return updateBank(newBank);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result inicial(),
    Result getBanksList(),
    Result updateAccountNumber(String accountNumber),
    Result updateBank(String newBank),
    Result updateAccountType(String newAccountType),
    Result createAccount(bool isInvestment),
    Result getBankAccounts(),
    Result chooseAccount(BankInfo bank),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (updateBank != null) {
      return updateBank(newBank);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result inicial(_initial value),
    @required Result getBanksList(_getBanksList value),
    @required Result updateAccountNumber(_updateAccountNumber value),
    @required Result updateBank(_updateBank value),
    @required Result updateAccountType(_updateAccountType value),
    @required Result createAccount(_createAccount value),
    @required Result getBankAccounts(_getBankAccounts value),
    @required Result chooseAccount(_chooseAccount value),
  }) {
    assert(inicial != null);
    assert(getBanksList != null);
    assert(updateAccountNumber != null);
    assert(updateBank != null);
    assert(updateAccountType != null);
    assert(createAccount != null);
    assert(getBankAccounts != null);
    assert(chooseAccount != null);
    return updateBank(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result inicial(_initial value),
    Result getBanksList(_getBanksList value),
    Result updateAccountNumber(_updateAccountNumber value),
    Result updateBank(_updateBank value),
    Result updateAccountType(_updateAccountType value),
    Result createAccount(_createAccount value),
    Result getBankAccounts(_getBankAccounts value),
    Result chooseAccount(_chooseAccount value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (updateBank != null) {
      return updateBank(this);
    }
    return orElse();
  }
}

abstract class _updateBank implements InvestingDomEvent {
  const factory _updateBank(String newBank) = _$_updateBank;

  String get newBank;

  _updateBank copyWith({String newBank});
}

class _$_updateAccountType implements _updateAccountType {
  const _$_updateAccountType(this.newAccountType)
      : assert(newAccountType != null);

  @override
  final String newAccountType;

  @override
  String toString() {
    return 'InvestingDomEvent.updateAccountType(newAccountType: $newAccountType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _updateAccountType &&
            (identical(other.newAccountType, newAccountType) ||
                const DeepCollectionEquality()
                    .equals(other.newAccountType, newAccountType)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(newAccountType);

  @override
  _$_updateAccountType copyWith({
    Object newAccountType = freezed,
  }) {
    return _$_updateAccountType(
      newAccountType == freezed
          ? this.newAccountType
          : newAccountType as String,
    );
  }

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result inicial(),
    @required Result getBanksList(),
    @required Result updateAccountNumber(String accountNumber),
    @required Result updateBank(String newBank),
    @required Result updateAccountType(String newAccountType),
    @required Result createAccount(bool isInvestment),
    @required Result getBankAccounts(),
    @required Result chooseAccount(BankInfo bank),
  }) {
    assert(inicial != null);
    assert(getBanksList != null);
    assert(updateAccountNumber != null);
    assert(updateBank != null);
    assert(updateAccountType != null);
    assert(createAccount != null);
    assert(getBankAccounts != null);
    assert(chooseAccount != null);
    return updateAccountType(newAccountType);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result inicial(),
    Result getBanksList(),
    Result updateAccountNumber(String accountNumber),
    Result updateBank(String newBank),
    Result updateAccountType(String newAccountType),
    Result createAccount(bool isInvestment),
    Result getBankAccounts(),
    Result chooseAccount(BankInfo bank),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (updateAccountType != null) {
      return updateAccountType(newAccountType);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result inicial(_initial value),
    @required Result getBanksList(_getBanksList value),
    @required Result updateAccountNumber(_updateAccountNumber value),
    @required Result updateBank(_updateBank value),
    @required Result updateAccountType(_updateAccountType value),
    @required Result createAccount(_createAccount value),
    @required Result getBankAccounts(_getBankAccounts value),
    @required Result chooseAccount(_chooseAccount value),
  }) {
    assert(inicial != null);
    assert(getBanksList != null);
    assert(updateAccountNumber != null);
    assert(updateBank != null);
    assert(updateAccountType != null);
    assert(createAccount != null);
    assert(getBankAccounts != null);
    assert(chooseAccount != null);
    return updateAccountType(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result inicial(_initial value),
    Result getBanksList(_getBanksList value),
    Result updateAccountNumber(_updateAccountNumber value),
    Result updateBank(_updateBank value),
    Result updateAccountType(_updateAccountType value),
    Result createAccount(_createAccount value),
    Result getBankAccounts(_getBankAccounts value),
    Result chooseAccount(_chooseAccount value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (updateAccountType != null) {
      return updateAccountType(this);
    }
    return orElse();
  }
}

abstract class _updateAccountType implements InvestingDomEvent {
  const factory _updateAccountType(String newAccountType) =
      _$_updateAccountType;

  String get newAccountType;

  _updateAccountType copyWith({String newAccountType});
}

class _$_createAccount implements _createAccount {
  const _$_createAccount(this.isInvestment) : assert(isInvestment != null);

  @override
  final bool isInvestment;

  @override
  String toString() {
    return 'InvestingDomEvent.createAccount(isInvestment: $isInvestment)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _createAccount &&
            (identical(other.isInvestment, isInvestment) ||
                const DeepCollectionEquality()
                    .equals(other.isInvestment, isInvestment)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(isInvestment);

  @override
  _$_createAccount copyWith({
    Object isInvestment = freezed,
  }) {
    return _$_createAccount(
      isInvestment == freezed ? this.isInvestment : isInvestment as bool,
    );
  }

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result inicial(),
    @required Result getBanksList(),
    @required Result updateAccountNumber(String accountNumber),
    @required Result updateBank(String newBank),
    @required Result updateAccountType(String newAccountType),
    @required Result createAccount(bool isInvestment),
    @required Result getBankAccounts(),
    @required Result chooseAccount(BankInfo bank),
  }) {
    assert(inicial != null);
    assert(getBanksList != null);
    assert(updateAccountNumber != null);
    assert(updateBank != null);
    assert(updateAccountType != null);
    assert(createAccount != null);
    assert(getBankAccounts != null);
    assert(chooseAccount != null);
    return createAccount(isInvestment);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result inicial(),
    Result getBanksList(),
    Result updateAccountNumber(String accountNumber),
    Result updateBank(String newBank),
    Result updateAccountType(String newAccountType),
    Result createAccount(bool isInvestment),
    Result getBankAccounts(),
    Result chooseAccount(BankInfo bank),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (createAccount != null) {
      return createAccount(isInvestment);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result inicial(_initial value),
    @required Result getBanksList(_getBanksList value),
    @required Result updateAccountNumber(_updateAccountNumber value),
    @required Result updateBank(_updateBank value),
    @required Result updateAccountType(_updateAccountType value),
    @required Result createAccount(_createAccount value),
    @required Result getBankAccounts(_getBankAccounts value),
    @required Result chooseAccount(_chooseAccount value),
  }) {
    assert(inicial != null);
    assert(getBanksList != null);
    assert(updateAccountNumber != null);
    assert(updateBank != null);
    assert(updateAccountType != null);
    assert(createAccount != null);
    assert(getBankAccounts != null);
    assert(chooseAccount != null);
    return createAccount(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result inicial(_initial value),
    Result getBanksList(_getBanksList value),
    Result updateAccountNumber(_updateAccountNumber value),
    Result updateBank(_updateBank value),
    Result updateAccountType(_updateAccountType value),
    Result createAccount(_createAccount value),
    Result getBankAccounts(_getBankAccounts value),
    Result chooseAccount(_chooseAccount value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (createAccount != null) {
      return createAccount(this);
    }
    return orElse();
  }
}

abstract class _createAccount implements InvestingDomEvent {
  const factory _createAccount(bool isInvestment) = _$_createAccount;

  bool get isInvestment;

  _createAccount copyWith({bool isInvestment});
}

class _$_getBankAccounts implements _getBankAccounts {
  const _$_getBankAccounts();

  @override
  String toString() {
    return 'InvestingDomEvent.getBankAccounts()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _getBankAccounts);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result inicial(),
    @required Result getBanksList(),
    @required Result updateAccountNumber(String accountNumber),
    @required Result updateBank(String newBank),
    @required Result updateAccountType(String newAccountType),
    @required Result createAccount(bool isInvestment),
    @required Result getBankAccounts(),
    @required Result chooseAccount(BankInfo bank),
  }) {
    assert(inicial != null);
    assert(getBanksList != null);
    assert(updateAccountNumber != null);
    assert(updateBank != null);
    assert(updateAccountType != null);
    assert(createAccount != null);
    assert(getBankAccounts != null);
    assert(chooseAccount != null);
    return getBankAccounts();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result inicial(),
    Result getBanksList(),
    Result updateAccountNumber(String accountNumber),
    Result updateBank(String newBank),
    Result updateAccountType(String newAccountType),
    Result createAccount(bool isInvestment),
    Result getBankAccounts(),
    Result chooseAccount(BankInfo bank),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (getBankAccounts != null) {
      return getBankAccounts();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result inicial(_initial value),
    @required Result getBanksList(_getBanksList value),
    @required Result updateAccountNumber(_updateAccountNumber value),
    @required Result updateBank(_updateBank value),
    @required Result updateAccountType(_updateAccountType value),
    @required Result createAccount(_createAccount value),
    @required Result getBankAccounts(_getBankAccounts value),
    @required Result chooseAccount(_chooseAccount value),
  }) {
    assert(inicial != null);
    assert(getBanksList != null);
    assert(updateAccountNumber != null);
    assert(updateBank != null);
    assert(updateAccountType != null);
    assert(createAccount != null);
    assert(getBankAccounts != null);
    assert(chooseAccount != null);
    return getBankAccounts(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result inicial(_initial value),
    Result getBanksList(_getBanksList value),
    Result updateAccountNumber(_updateAccountNumber value),
    Result updateBank(_updateBank value),
    Result updateAccountType(_updateAccountType value),
    Result createAccount(_createAccount value),
    Result getBankAccounts(_getBankAccounts value),
    Result chooseAccount(_chooseAccount value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (getBankAccounts != null) {
      return getBankAccounts(this);
    }
    return orElse();
  }
}

abstract class _getBankAccounts implements InvestingDomEvent {
  const factory _getBankAccounts() = _$_getBankAccounts;
}

class _$_chooseAccount implements _chooseAccount {
  const _$_chooseAccount(this.bank) : assert(bank != null);

  @override
  final BankInfo bank;

  @override
  String toString() {
    return 'InvestingDomEvent.chooseAccount(bank: $bank)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _chooseAccount &&
            (identical(other.bank, bank) ||
                const DeepCollectionEquality().equals(other.bank, bank)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(bank);

  @override
  _$_chooseAccount copyWith({
    Object bank = freezed,
  }) {
    return _$_chooseAccount(
      bank == freezed ? this.bank : bank as BankInfo,
    );
  }

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result inicial(),
    @required Result getBanksList(),
    @required Result updateAccountNumber(String accountNumber),
    @required Result updateBank(String newBank),
    @required Result updateAccountType(String newAccountType),
    @required Result createAccount(bool isInvestment),
    @required Result getBankAccounts(),
    @required Result chooseAccount(BankInfo bank),
  }) {
    assert(inicial != null);
    assert(getBanksList != null);
    assert(updateAccountNumber != null);
    assert(updateBank != null);
    assert(updateAccountType != null);
    assert(createAccount != null);
    assert(getBankAccounts != null);
    assert(chooseAccount != null);
    return chooseAccount(bank);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result inicial(),
    Result getBanksList(),
    Result updateAccountNumber(String accountNumber),
    Result updateBank(String newBank),
    Result updateAccountType(String newAccountType),
    Result createAccount(bool isInvestment),
    Result getBankAccounts(),
    Result chooseAccount(BankInfo bank),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (chooseAccount != null) {
      return chooseAccount(bank);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result inicial(_initial value),
    @required Result getBanksList(_getBanksList value),
    @required Result updateAccountNumber(_updateAccountNumber value),
    @required Result updateBank(_updateBank value),
    @required Result updateAccountType(_updateAccountType value),
    @required Result createAccount(_createAccount value),
    @required Result getBankAccounts(_getBankAccounts value),
    @required Result chooseAccount(_chooseAccount value),
  }) {
    assert(inicial != null);
    assert(getBanksList != null);
    assert(updateAccountNumber != null);
    assert(updateBank != null);
    assert(updateAccountType != null);
    assert(createAccount != null);
    assert(getBankAccounts != null);
    assert(chooseAccount != null);
    return chooseAccount(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result inicial(_initial value),
    Result getBanksList(_getBanksList value),
    Result updateAccountNumber(_updateAccountNumber value),
    Result updateBank(_updateBank value),
    Result updateAccountType(_updateAccountType value),
    Result createAccount(_createAccount value),
    Result getBankAccounts(_getBankAccounts value),
    Result chooseAccount(_chooseAccount value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (chooseAccount != null) {
      return chooseAccount(this);
    }
    return orElse();
  }
}

abstract class _chooseAccount implements InvestingDomEvent {
  const factory _chooseAccount(BankInfo bank) = _$_chooseAccount;

  BankInfo get bank;

  _chooseAccount copyWith({BankInfo bank});
}

mixin _$InvestingDomState {
  List<String> get accountTypes;
  List<String> get banksList;
  String get selectedBank;
  String get accountType;
  String get accountNumber;
  String get rfc;
  bool get checkedBox;
  bool get posted;
  BankAccountItem get accountItem;
  Map<int, String> get banksWithId;
  String get error;
  bool get isSubmitting;
  bool get banksFetched;
  List<BankInfo> get bankAccounts;
  BankAccountItem get bankChosen;

  InvestingDomState copyWith(
      {List<String> accountTypes,
      List<String> banksList,
      String selectedBank,
      String accountType,
      String accountNumber,
      String rfc,
      bool checkedBox,
      bool posted,
      BankAccountItem accountItem,
      Map<int, String> banksWithId,
      String error,
      bool isSubmitting,
      bool banksFetched,
      List<BankInfo> bankAccounts,
      BankAccountItem bankChosen});
}

class _$InvestingDomStateTearOff {
  const _$InvestingDomStateTearOff();

  _InvestingDomState call(
      {@required List<String> accountTypes,
      @required List<String> banksList,
      @required String selectedBank,
      @required String accountType,
      @required String accountNumber,
      @required String rfc,
      @required bool checkedBox,
      @required bool posted,
      @required BankAccountItem accountItem,
      @required Map<int, String> banksWithId,
      @required String error,
      bool isSubmitting,
      bool banksFetched,
      List<BankInfo> bankAccounts,
      BankAccountItem bankChosen}) {
    return _InvestingDomState(
      accountTypes: accountTypes,
      banksList: banksList,
      selectedBank: selectedBank,
      accountType: accountType,
      accountNumber: accountNumber,
      rfc: rfc,
      checkedBox: checkedBox,
      posted: posted,
      accountItem: accountItem,
      banksWithId: banksWithId,
      error: error,
      isSubmitting: isSubmitting,
      banksFetched: banksFetched,
      bankAccounts: bankAccounts,
      bankChosen: bankChosen,
    );
  }
}

const $InvestingDomState = _$InvestingDomStateTearOff();

class _$_InvestingDomState implements _InvestingDomState {
  const _$_InvestingDomState(
      {@required this.accountTypes,
      @required this.banksList,
      @required this.selectedBank,
      @required this.accountType,
      @required this.accountNumber,
      @required this.rfc,
      @required this.checkedBox,
      @required this.posted,
      @required this.accountItem,
      @required this.banksWithId,
      @required this.error,
      this.isSubmitting,
      this.banksFetched,
      this.bankAccounts,
      this.bankChosen})
      : assert(accountTypes != null),
        assert(banksList != null),
        assert(selectedBank != null),
        assert(accountType != null),
        assert(accountNumber != null),
        assert(rfc != null),
        assert(checkedBox != null),
        assert(posted != null),
        assert(accountItem != null),
        assert(banksWithId != null),
        assert(error != null);

  @override
  final List<String> accountTypes;
  @override
  final List<String> banksList;
  @override
  final String selectedBank;
  @override
  final String accountType;
  @override
  final String accountNumber;
  @override
  final String rfc;
  @override
  final bool checkedBox;
  @override
  final bool posted;
  @override
  final BankAccountItem accountItem;
  @override
  final Map<int, String> banksWithId;
  @override
  final String error;
  @override
  final bool isSubmitting;
  @override
  final bool banksFetched;
  @override
  final List<BankInfo> bankAccounts;
  @override
  final BankAccountItem bankChosen;

  @override
  String toString() {
    return 'InvestingDomState(accountTypes: $accountTypes, banksList: $banksList, selectedBank: $selectedBank, accountType: $accountType, accountNumber: $accountNumber, rfc: $rfc, checkedBox: $checkedBox, posted: $posted, accountItem: $accountItem, banksWithId: $banksWithId, error: $error, isSubmitting: $isSubmitting, banksFetched: $banksFetched, bankAccounts: $bankAccounts, bankChosen: $bankChosen)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _InvestingDomState &&
            (identical(other.accountTypes, accountTypes) ||
                const DeepCollectionEquality()
                    .equals(other.accountTypes, accountTypes)) &&
            (identical(other.banksList, banksList) ||
                const DeepCollectionEquality()
                    .equals(other.banksList, banksList)) &&
            (identical(other.selectedBank, selectedBank) ||
                const DeepCollectionEquality()
                    .equals(other.selectedBank, selectedBank)) &&
            (identical(other.accountType, accountType) ||
                const DeepCollectionEquality()
                    .equals(other.accountType, accountType)) &&
            (identical(other.accountNumber, accountNumber) ||
                const DeepCollectionEquality()
                    .equals(other.accountNumber, accountNumber)) &&
            (identical(other.rfc, rfc) ||
                const DeepCollectionEquality().equals(other.rfc, rfc)) &&
            (identical(other.checkedBox, checkedBox) ||
                const DeepCollectionEquality()
                    .equals(other.checkedBox, checkedBox)) &&
            (identical(other.posted, posted) ||
                const DeepCollectionEquality().equals(other.posted, posted)) &&
            (identical(other.accountItem, accountItem) ||
                const DeepCollectionEquality()
                    .equals(other.accountItem, accountItem)) &&
            (identical(other.banksWithId, banksWithId) ||
                const DeepCollectionEquality()
                    .equals(other.banksWithId, banksWithId)) &&
            (identical(other.error, error) ||
                const DeepCollectionEquality().equals(other.error, error)) &&
            (identical(other.isSubmitting, isSubmitting) ||
                const DeepCollectionEquality()
                    .equals(other.isSubmitting, isSubmitting)) &&
            (identical(other.banksFetched, banksFetched) ||
                const DeepCollectionEquality()
                    .equals(other.banksFetched, banksFetched)) &&
            (identical(other.bankAccounts, bankAccounts) ||
                const DeepCollectionEquality()
                    .equals(other.bankAccounts, bankAccounts)) &&
            (identical(other.bankChosen, bankChosen) ||
                const DeepCollectionEquality()
                    .equals(other.bankChosen, bankChosen)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(accountTypes) ^
      const DeepCollectionEquality().hash(banksList) ^
      const DeepCollectionEquality().hash(selectedBank) ^
      const DeepCollectionEquality().hash(accountType) ^
      const DeepCollectionEquality().hash(accountNumber) ^
      const DeepCollectionEquality().hash(rfc) ^
      const DeepCollectionEquality().hash(checkedBox) ^
      const DeepCollectionEquality().hash(posted) ^
      const DeepCollectionEquality().hash(accountItem) ^
      const DeepCollectionEquality().hash(banksWithId) ^
      const DeepCollectionEquality().hash(error) ^
      const DeepCollectionEquality().hash(isSubmitting) ^
      const DeepCollectionEquality().hash(banksFetched) ^
      const DeepCollectionEquality().hash(bankAccounts) ^
      const DeepCollectionEquality().hash(bankChosen);

  @override
  _$_InvestingDomState copyWith({
    Object accountTypes = freezed,
    Object banksList = freezed,
    Object selectedBank = freezed,
    Object accountType = freezed,
    Object accountNumber = freezed,
    Object rfc = freezed,
    Object checkedBox = freezed,
    Object posted = freezed,
    Object accountItem = freezed,
    Object banksWithId = freezed,
    Object error = freezed,
    Object isSubmitting = freezed,
    Object banksFetched = freezed,
    Object bankAccounts = freezed,
    Object bankChosen = freezed,
  }) {
    return _$_InvestingDomState(
      accountTypes: accountTypes == freezed
          ? this.accountTypes
          : accountTypes as List<String>,
      banksList:
          banksList == freezed ? this.banksList : banksList as List<String>,
      selectedBank:
          selectedBank == freezed ? this.selectedBank : selectedBank as String,
      accountType:
          accountType == freezed ? this.accountType : accountType as String,
      accountNumber: accountNumber == freezed
          ? this.accountNumber
          : accountNumber as String,
      rfc: rfc == freezed ? this.rfc : rfc as String,
      checkedBox: checkedBox == freezed ? this.checkedBox : checkedBox as bool,
      posted: posted == freezed ? this.posted : posted as bool,
      accountItem: accountItem == freezed
          ? this.accountItem
          : accountItem as BankAccountItem,
      banksWithId: banksWithId == freezed
          ? this.banksWithId
          : banksWithId as Map<int, String>,
      error: error == freezed ? this.error : error as String,
      isSubmitting:
          isSubmitting == freezed ? this.isSubmitting : isSubmitting as bool,
      banksFetched:
          banksFetched == freezed ? this.banksFetched : banksFetched as bool,
      bankAccounts: bankAccounts == freezed
          ? this.bankAccounts
          : bankAccounts as List<BankInfo>,
      bankChosen: bankChosen == freezed
          ? this.bankChosen
          : bankChosen as BankAccountItem,
    );
  }
}

abstract class _InvestingDomState implements InvestingDomState {
  const factory _InvestingDomState(
      {@required List<String> accountTypes,
      @required List<String> banksList,
      @required String selectedBank,
      @required String accountType,
      @required String accountNumber,
      @required String rfc,
      @required bool checkedBox,
      @required bool posted,
      @required BankAccountItem accountItem,
      @required Map<int, String> banksWithId,
      @required String error,
      bool isSubmitting,
      bool banksFetched,
      List<BankInfo> bankAccounts,
      BankAccountItem bankChosen}) = _$_InvestingDomState;

  @override
  List<String> get accountTypes;
  @override
  List<String> get banksList;
  @override
  String get selectedBank;
  @override
  String get accountType;
  @override
  String get accountNumber;
  @override
  String get rfc;
  @override
  bool get checkedBox;
  @override
  bool get posted;
  @override
  BankAccountItem get accountItem;
  @override
  Map<int, String> get banksWithId;
  @override
  String get error;
  @override
  bool get isSubmitting;
  @override
  bool get banksFetched;
  @override
  List<BankInfo> get bankAccounts;
  @override
  BankAccountItem get bankChosen;

  @override
  _InvestingDomState copyWith(
      {List<String> accountTypes,
      List<String> banksList,
      String selectedBank,
      String accountType,
      String accountNumber,
      String rfc,
      bool checkedBox,
      bool posted,
      BankAccountItem accountItem,
      Map<int, String> banksWithId,
      String error,
      bool isSubmitting,
      bool banksFetched,
      List<BankInfo> bankAccounts,
      BankAccountItem bankChosen});
}
